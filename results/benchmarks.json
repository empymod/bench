{
    "kernel.Kernel.time_fields": {
        "code": "class Kernel:\n    def time_fields(self, data, size):\n        kernel.fields(**data[size]['fields'])\n\n    def setup_cache(self):\n        \"\"\"setup_cache is not parametrized, so we do it manually. \"\"\"\n    \n        data = {}\n        for size in self.params[0]:\n            data[size] = {}\n    \n            if size == 'Small':\n                freq = np.array([1])\n                off = np.array([500.])\n                base = np.array([1])\n            else:\n                freq = np.logspace(-2, 2, 100)\n                off = np.arange(1, 101)*200.\n                base = filters.key_201_2009().base\n    \n            # Define survey\n            lsrc = 1\n            lrec = 1\n            ab = 11\n            msrc = False\n            mrec = False\n    \n            if VERSION2:\n                zsrc = 250.\n                zrec = 300.\n            else:\n                zsrc = np.array([250.])  # Not sure if this distinction\n                zrec = np.array([300.])  # is actually needed\n                use_ne_eval = False\n    \n            # Define model\n            depth = np.array([-np.infty, 0, 300, 2000, 2100])\n            res = np.array([2e14, .3, 1, 50, 1])\n            aniso = np.ones(res.shape)\n            epermH = np.ones(res.shape)\n            epermV = np.ones(res.shape)\n            mpermH = np.ones(res.shape)\n            mpermV = np.ones(res.shape)\n    \n            # Other parameters\n            xdirect = False\n            TM = True\n    \n            # Compute eta, zeta, wavenumber, Gamma\n            etaH = 1/res + np.outer(2j*np.pi*freq, epermH*epsilon_0)\n            etaV = 1/(res*aniso*aniso) + np.outer(2j*np.pi*freq,\n                                                  epermV*epsilon_0)\n            zetaH = np.outer(2j*np.pi*freq, mpermH*mu_0)\n            zetaV = np.outer(2j*np.pi*freq, mpermV*mu_0)\n            lambd = base/off[:, None]\n            Gam = np.sqrt((etaH/etaV)[:, None, :, None] *\n                          (lambd*lambd)[None, :, None, :] +\n                          (zetaH*etaH)[:, None, :, None])\n    \n            # Collect input for kernel.greenfct()\n            green_wave = {'zsrc': zsrc, 'zrec': zrec, 'lsrc': lsrc, 'lrec':\n                          lrec, 'depth': depth, 'etaH': etaH, 'etaV': etaV,\n                          'zetaH': zetaH, 'zetaV': zetaV, 'lambd': lambd, 'ab':\n                          ab, 'xdirect': xdirect, 'msrc': msrc, 'mrec': mrec}\n    \n            # Collect input for kernel.reflections()\n            reflections = {'depth': depth, 'e_zH': etaH, 'Gam': Gam, 'lrec':\n                           lrec, 'lsrc': lsrc}\n    \n            if not VERSION2:\n                green_wave['use_ne_eval'] = use_ne_eval\n                reflections['use_ne_eval'] = use_ne_eval\n    \n            # Compute plus/minus reflection coefficients\n            Rp, Rm = kernel.reflections(**reflections)\n    \n            # Collect input for kernel.fields()\n            fields = {'depth': depth, 'Gam': Gam, 'lrec': lrec, 'lsrc': lsrc,\n                      'Rp': Rp, 'Rm': Rm, 'zsrc': zsrc, 'ab': ab, 'TM': TM}\n            if not VERSION2:\n                fields['use_ne_eval'] = use_ne_eval\n    \n            # Add to dict.\n            data[size]['green_wave'] = green_wave\n            data[size]['reflections'] = reflections\n            data[size]['fields'] = fields\n    \n        return data",
        "min_run_count": 2,
        "name": "kernel.Kernel.time_fields",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "'Small'",
                "'Big'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "setup_cache_key": "/home/dtr/Codes/empymod-asv/benchmarks/kernel.py:39",
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f98f1365b371a5580c0353eff53214eb636c20ed79e068d2c8b8dfed450b2e09",
        "warmup_time": -1
    },
    "kernel.Kernel.time_greenfct": {
        "code": "class Kernel:\n    def time_greenfct(self, data, size):\n        kernel.greenfct(**data[size]['green_wave'])\n\n    def setup_cache(self):\n        \"\"\"setup_cache is not parametrized, so we do it manually. \"\"\"\n    \n        data = {}\n        for size in self.params[0]:\n            data[size] = {}\n    \n            if size == 'Small':\n                freq = np.array([1])\n                off = np.array([500.])\n                base = np.array([1])\n            else:\n                freq = np.logspace(-2, 2, 100)\n                off = np.arange(1, 101)*200.\n                base = filters.key_201_2009().base\n    \n            # Define survey\n            lsrc = 1\n            lrec = 1\n            ab = 11\n            msrc = False\n            mrec = False\n    \n            if VERSION2:\n                zsrc = 250.\n                zrec = 300.\n            else:\n                zsrc = np.array([250.])  # Not sure if this distinction\n                zrec = np.array([300.])  # is actually needed\n                use_ne_eval = False\n    \n            # Define model\n            depth = np.array([-np.infty, 0, 300, 2000, 2100])\n            res = np.array([2e14, .3, 1, 50, 1])\n            aniso = np.ones(res.shape)\n            epermH = np.ones(res.shape)\n            epermV = np.ones(res.shape)\n            mpermH = np.ones(res.shape)\n            mpermV = np.ones(res.shape)\n    \n            # Other parameters\n            xdirect = False\n            TM = True\n    \n            # Compute eta, zeta, wavenumber, Gamma\n            etaH = 1/res + np.outer(2j*np.pi*freq, epermH*epsilon_0)\n            etaV = 1/(res*aniso*aniso) + np.outer(2j*np.pi*freq,\n                                                  epermV*epsilon_0)\n            zetaH = np.outer(2j*np.pi*freq, mpermH*mu_0)\n            zetaV = np.outer(2j*np.pi*freq, mpermV*mu_0)\n            lambd = base/off[:, None]\n            Gam = np.sqrt((etaH/etaV)[:, None, :, None] *\n                          (lambd*lambd)[None, :, None, :] +\n                          (zetaH*etaH)[:, None, :, None])\n    \n            # Collect input for kernel.greenfct()\n            green_wave = {'zsrc': zsrc, 'zrec': zrec, 'lsrc': lsrc, 'lrec':\n                          lrec, 'depth': depth, 'etaH': etaH, 'etaV': etaV,\n                          'zetaH': zetaH, 'zetaV': zetaV, 'lambd': lambd, 'ab':\n                          ab, 'xdirect': xdirect, 'msrc': msrc, 'mrec': mrec}\n    \n            # Collect input for kernel.reflections()\n            reflections = {'depth': depth, 'e_zH': etaH, 'Gam': Gam, 'lrec':\n                           lrec, 'lsrc': lsrc}\n    \n            if not VERSION2:\n                green_wave['use_ne_eval'] = use_ne_eval\n                reflections['use_ne_eval'] = use_ne_eval\n    \n            # Compute plus/minus reflection coefficients\n            Rp, Rm = kernel.reflections(**reflections)\n    \n            # Collect input for kernel.fields()\n            fields = {'depth': depth, 'Gam': Gam, 'lrec': lrec, 'lsrc': lsrc,\n                      'Rp': Rp, 'Rm': Rm, 'zsrc': zsrc, 'ab': ab, 'TM': TM}\n            if not VERSION2:\n                fields['use_ne_eval'] = use_ne_eval\n    \n            # Add to dict.\n            data[size]['green_wave'] = green_wave\n            data[size]['reflections'] = reflections\n            data[size]['fields'] = fields\n    \n        return data",
        "min_run_count": 2,
        "name": "kernel.Kernel.time_greenfct",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "'Small'",
                "'Big'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "setup_cache_key": "/home/dtr/Codes/empymod-asv/benchmarks/kernel.py:39",
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c3d5fedaea5f34aa73e47c03b1d1f767cce1f75c19c78607e11434d3dd4b0b55",
        "warmup_time": -1
    },
    "kernel.Kernel.time_reflections": {
        "code": "class Kernel:\n    def time_reflections(self, data, size):\n        kernel.reflections(**data[size]['reflections'])\n\n    def setup_cache(self):\n        \"\"\"setup_cache is not parametrized, so we do it manually. \"\"\"\n    \n        data = {}\n        for size in self.params[0]:\n            data[size] = {}\n    \n            if size == 'Small':\n                freq = np.array([1])\n                off = np.array([500.])\n                base = np.array([1])\n            else:\n                freq = np.logspace(-2, 2, 100)\n                off = np.arange(1, 101)*200.\n                base = filters.key_201_2009().base\n    \n            # Define survey\n            lsrc = 1\n            lrec = 1\n            ab = 11\n            msrc = False\n            mrec = False\n    \n            if VERSION2:\n                zsrc = 250.\n                zrec = 300.\n            else:\n                zsrc = np.array([250.])  # Not sure if this distinction\n                zrec = np.array([300.])  # is actually needed\n                use_ne_eval = False\n    \n            # Define model\n            depth = np.array([-np.infty, 0, 300, 2000, 2100])\n            res = np.array([2e14, .3, 1, 50, 1])\n            aniso = np.ones(res.shape)\n            epermH = np.ones(res.shape)\n            epermV = np.ones(res.shape)\n            mpermH = np.ones(res.shape)\n            mpermV = np.ones(res.shape)\n    \n            # Other parameters\n            xdirect = False\n            TM = True\n    \n            # Compute eta, zeta, wavenumber, Gamma\n            etaH = 1/res + np.outer(2j*np.pi*freq, epermH*epsilon_0)\n            etaV = 1/(res*aniso*aniso) + np.outer(2j*np.pi*freq,\n                                                  epermV*epsilon_0)\n            zetaH = np.outer(2j*np.pi*freq, mpermH*mu_0)\n            zetaV = np.outer(2j*np.pi*freq, mpermV*mu_0)\n            lambd = base/off[:, None]\n            Gam = np.sqrt((etaH/etaV)[:, None, :, None] *\n                          (lambd*lambd)[None, :, None, :] +\n                          (zetaH*etaH)[:, None, :, None])\n    \n            # Collect input for kernel.greenfct()\n            green_wave = {'zsrc': zsrc, 'zrec': zrec, 'lsrc': lsrc, 'lrec':\n                          lrec, 'depth': depth, 'etaH': etaH, 'etaV': etaV,\n                          'zetaH': zetaH, 'zetaV': zetaV, 'lambd': lambd, 'ab':\n                          ab, 'xdirect': xdirect, 'msrc': msrc, 'mrec': mrec}\n    \n            # Collect input for kernel.reflections()\n            reflections = {'depth': depth, 'e_zH': etaH, 'Gam': Gam, 'lrec':\n                           lrec, 'lsrc': lsrc}\n    \n            if not VERSION2:\n                green_wave['use_ne_eval'] = use_ne_eval\n                reflections['use_ne_eval'] = use_ne_eval\n    \n            # Compute plus/minus reflection coefficients\n            Rp, Rm = kernel.reflections(**reflections)\n    \n            # Collect input for kernel.fields()\n            fields = {'depth': depth, 'Gam': Gam, 'lrec': lrec, 'lsrc': lsrc,\n                      'Rp': Rp, 'Rm': Rm, 'zsrc': zsrc, 'ab': ab, 'TM': TM}\n            if not VERSION2:\n                fields['use_ne_eval'] = use_ne_eval\n    \n            # Add to dict.\n            data[size]['green_wave'] = green_wave\n            data[size]['reflections'] = reflections\n            data[size]['fields'] = fields\n    \n        return data",
        "min_run_count": 2,
        "name": "kernel.Kernel.time_reflections",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "'Small'",
                "'Big'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "setup_cache_key": "/home/dtr/Codes/empymod-asv/benchmarks/kernel.py:39",
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "72216c7465fa9a666a0116e54b3de5a0e25d98ab90f11e2f9477756d532754e5",
        "warmup_time": -1
    },
    "kernel.Kernel.time_wavenumber": {
        "code": "class Kernel:\n    def time_wavenumber(self, data, size):\n        kernel.wavenumber(**data[size]['green_wave'])\n\n    def setup_cache(self):\n        \"\"\"setup_cache is not parametrized, so we do it manually. \"\"\"\n    \n        data = {}\n        for size in self.params[0]:\n            data[size] = {}\n    \n            if size == 'Small':\n                freq = np.array([1])\n                off = np.array([500.])\n                base = np.array([1])\n            else:\n                freq = np.logspace(-2, 2, 100)\n                off = np.arange(1, 101)*200.\n                base = filters.key_201_2009().base\n    \n            # Define survey\n            lsrc = 1\n            lrec = 1\n            ab = 11\n            msrc = False\n            mrec = False\n    \n            if VERSION2:\n                zsrc = 250.\n                zrec = 300.\n            else:\n                zsrc = np.array([250.])  # Not sure if this distinction\n                zrec = np.array([300.])  # is actually needed\n                use_ne_eval = False\n    \n            # Define model\n            depth = np.array([-np.infty, 0, 300, 2000, 2100])\n            res = np.array([2e14, .3, 1, 50, 1])\n            aniso = np.ones(res.shape)\n            epermH = np.ones(res.shape)\n            epermV = np.ones(res.shape)\n            mpermH = np.ones(res.shape)\n            mpermV = np.ones(res.shape)\n    \n            # Other parameters\n            xdirect = False\n            TM = True\n    \n            # Compute eta, zeta, wavenumber, Gamma\n            etaH = 1/res + np.outer(2j*np.pi*freq, epermH*epsilon_0)\n            etaV = 1/(res*aniso*aniso) + np.outer(2j*np.pi*freq,\n                                                  epermV*epsilon_0)\n            zetaH = np.outer(2j*np.pi*freq, mpermH*mu_0)\n            zetaV = np.outer(2j*np.pi*freq, mpermV*mu_0)\n            lambd = base/off[:, None]\n            Gam = np.sqrt((etaH/etaV)[:, None, :, None] *\n                          (lambd*lambd)[None, :, None, :] +\n                          (zetaH*etaH)[:, None, :, None])\n    \n            # Collect input for kernel.greenfct()\n            green_wave = {'zsrc': zsrc, 'zrec': zrec, 'lsrc': lsrc, 'lrec':\n                          lrec, 'depth': depth, 'etaH': etaH, 'etaV': etaV,\n                          'zetaH': zetaH, 'zetaV': zetaV, 'lambd': lambd, 'ab':\n                          ab, 'xdirect': xdirect, 'msrc': msrc, 'mrec': mrec}\n    \n            # Collect input for kernel.reflections()\n            reflections = {'depth': depth, 'e_zH': etaH, 'Gam': Gam, 'lrec':\n                           lrec, 'lsrc': lsrc}\n    \n            if not VERSION2:\n                green_wave['use_ne_eval'] = use_ne_eval\n                reflections['use_ne_eval'] = use_ne_eval\n    \n            # Compute plus/minus reflection coefficients\n            Rp, Rm = kernel.reflections(**reflections)\n    \n            # Collect input for kernel.fields()\n            fields = {'depth': depth, 'Gam': Gam, 'lrec': lrec, 'lsrc': lsrc,\n                      'Rp': Rp, 'Rm': Rm, 'zsrc': zsrc, 'ab': ab, 'TM': TM}\n            if not VERSION2:\n                fields['use_ne_eval'] = use_ne_eval\n    \n            # Add to dict.\n            data[size]['green_wave'] = green_wave\n            data[size]['reflections'] = reflections\n            data[size]['fields'] = fields\n    \n        return data",
        "min_run_count": 2,
        "name": "kernel.Kernel.time_wavenumber",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "'Small'",
                "'Big'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "setup_cache_key": "/home/dtr/Codes/empymod-asv/benchmarks/kernel.py:39",
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f4e623f865f390d83a5b9319c503b8ef3f1c2ffa9bbd90dcaf30f106a49dd37a",
        "warmup_time": -1
    },
    "model.Analytical.time_analytical": {
        "code": "class Analytical:\n    def time_analytical(self, solution):\n        model.analytical(**self.hsfs_inp)\n\n    def setup(self, solution):\n        if solution == 'dfs':\n            signal = 0\n        else:\n            signal = None\n    \n        self.hsfs_inp = {\n                'src': [0, 0, 0],\n                'rec': [np.arange(1, 101)*200, np.zeros(100), 0],\n                'res': 3.5,\n                'freqtime': np.logspace(-2, 2, 101),\n                'signal': signal,\n                'solution': solution,\n                'verb': 0}",
        "min_run_count": 2,
        "name": "model.Analytical.time_analytical",
        "number": 0,
        "param_names": [
            "solution"
        ],
        "params": [
            [
                "'fs'",
                "'dhs'",
                "'dfs'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b07b2319ed2d72709b609713b1ba9e4ab118e013c11069916485523a4d57c64a",
        "warmup_time": -1
    },
    "model.Bipole.time_frequency": {
        "code": "class Bipole:\n    def time_frequency(self):\n        model.bipole(\n                src=[[-50, 0], [0, 30],\n                     [0, 10], [5, 50],\n                     [970, 999], [980, 990]],\n                rec=[[2000, 3000], [2100, 3200],\n                     [0, 200], [100, 400],\n                     [960, 970], [950, 1000]],\n                depth=[0, 1000, 2000, 2100],\n                res=[2e14, 0.3, 1, 100, 1],\n                freqtime=[0.1, 1.0, 10.],\n                srcpts=5, recpts=5, strength=1000,\n                htarg='key_201_2009',\n                xdirect=False, verb=0)",
        "min_run_count": 2,
        "name": "model.Bipole.time_frequency",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "3c2c4b7982c86ab3bea2eec4ec5db8dc403922f5f4e3833e5828018ec7457c74",
        "warmup_time": -1
    },
    "model.Bipole.time_time": {
        "code": "class Bipole:\n    def time_time(self):\n        model.bipole(\n                src=[0, 0, 950, 10, 30],\n                rec=[3000, 100, 1000, 5, 7],\n                depth=[0, 1000, 2000, 2100],\n                res=[2e14, 0.3, 1, 100, 1],\n                freqtime=[0.1, 1.0, 10.],\n                htarg='key_201_2009',\n                srcpts=1, recpts=1, strength=0,\n                signal=-1, xdirect=False, verb=0)",
        "min_run_count": 2,
        "name": "model.Bipole.time_time",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d5ecf8fab1bc77fd8ab8c959794404ee39c78cb1047e3eccdc23b7c868b72eb9",
        "warmup_time": -1
    },
    "model.Dipole.time_frequency": {
        "code": "class Dipole:\n    def time_frequency(self, loop):\n        self.freq(rec=[np.arange(1, 21)*300, np.zeros(20), 1000],\n                  **self.fmodel)\n\n    def setup(self, loop):\n        self.model = {\n                'src': [0, 0, 990],\n                'depth': [0, 1000, 2000, 2100],\n                'res': [2e14, 0.3, 1, 100, 1],\n                'xdirect': False,\n                'htarg': 'key_201_2009',\n                'loop': loop,\n                'verb': 0}\n        if not VERSION2:\n            self.model['opt'] = None\n    \n        self.freqtime = np.logspace(-2, 2, 21)\n        self.fmodel = dc(self.model)\n        self.tmodel = dc(self.model)\n    \n        # Till c73d6647 (btw. v1.0.0 and v1.1.0) there were the routines\n        # `frequency` and `time`, which were later merged into `dipole`.\n        try:\n            # Test\n            model.dipole([0, 0, 1], [10, 0, 2], [], 1, 1, verb=0)\n            # Frequency\n            self.freq = model.dipole\n            self.fmodel['freqtime'] = self.freqtime\n            # Time\n            self.time = model.dipole\n            self.tmodel['freqtime'] = self.freqtime\n        except VariableCatch:\n            # Frequency\n            self.freq = model.frequency\n            self.fmodel['freq'] = self.freqtime\n            # Time\n            self.time = model.time\n            self.tmodel['time'] = self.freqtime",
        "min_run_count": 2,
        "name": "model.Dipole.time_frequency",
        "number": 0,
        "param_names": [
            "loop"
        ],
        "params": [
            [
                "None",
                "'freq'",
                "'off'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "096dfbd8ce6e71c565842b2d6547facd5b6bfce41dbd05ab5e16c1d8365ba274",
        "warmup_time": -1
    },
    "model.Dipole.time_time": {
        "code": "class Dipole:\n    def time_time(self, loop):\n        self.time(rec=[np.arange(1, 4)*1000, np.zeros(3), 1000],\n                  signal=0, **self.tmodel)\n\n    def setup(self, loop):\n        self.model = {\n                'src': [0, 0, 990],\n                'depth': [0, 1000, 2000, 2100],\n                'res': [2e14, 0.3, 1, 100, 1],\n                'xdirect': False,\n                'htarg': 'key_201_2009',\n                'loop': loop,\n                'verb': 0}\n        if not VERSION2:\n            self.model['opt'] = None\n    \n        self.freqtime = np.logspace(-2, 2, 21)\n        self.fmodel = dc(self.model)\n        self.tmodel = dc(self.model)\n    \n        # Till c73d6647 (btw. v1.0.0 and v1.1.0) there were the routines\n        # `frequency` and `time`, which were later merged into `dipole`.\n        try:\n            # Test\n            model.dipole([0, 0, 1], [10, 0, 2], [], 1, 1, verb=0)\n            # Frequency\n            self.freq = model.dipole\n            self.fmodel['freqtime'] = self.freqtime\n            # Time\n            self.time = model.dipole\n            self.tmodel['freqtime'] = self.freqtime\n        except VariableCatch:\n            # Frequency\n            self.freq = model.frequency\n            self.fmodel['freq'] = self.freqtime\n            # Time\n            self.time = model.time\n            self.tmodel['time'] = self.freqtime",
        "min_run_count": 2,
        "name": "model.Dipole.time_time",
        "number": 0,
        "param_names": [
            "loop"
        ],
        "params": [
            [
                "None",
                "'freq'",
                "'off'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1e6fe7a07a42ae38de8f9ab2dc41b03df818a2613d52e383720ef0d3c92fcbc9",
        "warmup_time": -1
    },
    "model.VariousDipole.time_difflsrclrec_42": {
        "code": "class VariousDipole:\n    def time_difflsrclrec_42(self):\n        # First arguments without name, for backwards comp. with `frequency`\n        self.func([0, 0, -20],             # src\n                  [np.arange(1, 11)*600, np.zeros(10), 100],  # rec\n                  [0, 50],                 # Depth\n                  [2e14, 10, 1],           # Resistivities\n                  np.logspace(-2, 2, 11),  # Frequencies\n                  aniso=[1, 2, 0.5], ab=42, xdirect=False,\n                  htarg='key_101_2009', verb=0)\n\n    def setup(self):\n    \n        # Till c73d6647 (btw. v1.0.0 and v1.1.0) there were the routines\n        # `frequency` and `time`, which were later merged into `dipole`.\n        try:\n            model.dipole([0, 0, 1], [10, 0, 2], [], 1, 1, verb=0)\n            self.func = model.dipole\n        except VariableCatch:\n            self.func = model.frequency",
        "min_run_count": 2,
        "name": "model.VariousDipole.time_difflsrclrec_42",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "77e932abb54b93da445de63566806def0113bfdd8b194c3d23438a60f2567e19",
        "warmup_time": -1
    },
    "model.VariousDipole.time_highfreq_11": {
        "code": "class VariousDipole:\n    def time_highfreq_11(self):\n        # First arguments without name, for backwards comp. with `frequency`\n        self.func([0, 0, 2],              # src\n                  [np.arange(1, 11), np.arange(1, 11)/4, 3],  # rec\n                  [0, 10],                # Depth\n                  [2e14, 10, 100],        # Resistivities\n                  np.logspace(6, 8, 11),  # Frequencies\n                  aniso=[1, 2, 0.5], ab=11, epermH=[1, 80, 5],\n                  epermV=[1, 40, 10], mpermH=[1, 1, 4], mpermV=[1, 2, 0.5],\n                  xdirect=False, htarg='key_401_2009', verb=0)\n\n    def setup(self):\n    \n        # Till c73d6647 (btw. v1.0.0 and v1.1.0) there were the routines\n        # `frequency` and `time`, which were later merged into `dipole`.\n        try:\n            model.dipole([0, 0, 1], [10, 0, 2], [], 1, 1, verb=0)\n            self.func = model.dipole\n        except VariableCatch:\n            self.func = model.frequency",
        "min_run_count": 2,
        "name": "model.VariousDipole.time_highfreq_11",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "66bb5d51611305cb591c36598fca241b0ca0ae7af25730309886d3d585f98846",
        "warmup_time": -1
    },
    "model.VariousDipole.time_land_angle_16": {
        "code": "class VariousDipole:\n    def time_land_angle_16(self):\n        # First arguments without name, for backwards comp. with `frequency`\n        self.func([0, 0, 1e-5],            # src\n                  [np.arange(1, 11)*600, np.arange(1, 11)*400, 1e-5],  # rec\n                  0,                       # Depth\n                  [2e14, 10],              # Resistivities\n                  np.logspace(-2, 2, 11),  # Frequencies\n                  ab=16, epermH=[0, 1], epermV=[0, 1], xdirect=False,\n                  htarg='key_101_2009', verb=0)\n\n    def setup(self):\n    \n        # Till c73d6647 (btw. v1.0.0 and v1.1.0) there were the routines\n        # `frequency` and `time`, which were later merged into `dipole`.\n        try:\n            model.dipole([0, 0, 1], [10, 0, 2], [], 1, 1, verb=0)\n            self.func = model.dipole\n        except VariableCatch:\n            self.func = model.frequency",
        "min_run_count": 2,
        "name": "model.VariousDipole.time_land_angle_16",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "709140abfccdc1a472749b162ccb2aa192e3648c0e1993caab57ed56fb96781b",
        "warmup_time": -1
    },
    "model.VariousDipole.time_marine_angle_12": {
        "code": "class VariousDipole:\n    def time_marine_angle_12(self):\n        # First arguments without name, for backwards comp. with `frequency`\n        self.func([0, 0, 990],             # src\n                  [np.arange(1, 11)*600, np.arange(1, 11)*400, 1000],  # rec\n                  [0, 1000],               # Depths\n                  [2e14, 0.3, 1],          # Resistivities\n                  np.logspace(-2, 2, 11),  # Frequencies\n                  ab=12, xdirect=False, htarg='key_101_2009', verb=0)\n\n    def setup(self):\n    \n        # Till c73d6647 (btw. v1.0.0 and v1.1.0) there were the routines\n        # `frequency` and `time`, which were later merged into `dipole`.\n        try:\n            model.dipole([0, 0, 1], [10, 0, 2], [], 1, 1, verb=0)\n            self.func = model.dipole\n        except VariableCatch:\n            self.func = model.frequency",
        "min_run_count": 2,
        "name": "model.VariousDipole.time_marine_angle_12",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "5653f860fe5006930701606fe33b70003de50390d389b5953a152e8ed857d010",
        "warmup_time": -1
    },
    "transform.Dlf.time_dlf": {
        "code": "class Dlf:\n    def time_dlf(self, data, size, htype):\n        transform.dlf(**data[size][htype])\n\n    def setup_cache(self):\n        \"\"\"setup_cache is not parametrized, so we do it manually. \"\"\"\n    \n        data = {}\n        for size in self.params[0]:  # size\n    \n            data[size] = {}\n    \n            # One big, one small model\n            if size == 'Small':  # Small; Total size: 5*1*1*1 = 5\n                x = np.array([500., 1000.])\n            else:       # Big; Total size: 5*100*100*201 = 10'050'000\n                x = np.arange(1, 101)*200.\n    \n            # Define model parameters\n            freq = np.array([1])\n            src = [0, 0, 250]\n            rec = [x, np.zeros(x.shape), 300]\n            depth = np.array([-np.infty, 0, 300, 2000, 2100])\n            res = np.array([2e14, .3, 1, 50, 1])\n            ab = 11\n            xdirect = False\n            verb = 0\n    \n            if not VERSION2:\n                use_ne_eval = False\n    \n            # Checks (since DLF exists the `utils`-checks haven't changed, so\n            # we just use them here.\n            model = utils.check_model(depth, res, None, None, None, None, None,\n                                      xdirect, verb)\n            depth, res, aniso, epermH, epermV, mpermH, mpermV, _ = model\n            frequency = utils.check_frequency(freq, res, aniso, epermH, epermV,\n                                              mpermH, mpermV, verb)\n            freq, etaH, etaV, zetaH, zetaV = frequency\n            ab, msrc, mrec = utils.check_ab(ab, verb)\n            src, nsrc = utils.check_dipole(src, 'src', verb)\n            rec, nrec = utils.check_dipole(rec, 'rec', verb)\n            off, angle = utils.get_off_ang(src, rec, nsrc, nrec, verb)\n            lsrc, zsrc = utils.get_layer_nr(src, depth)\n            lrec, zrec = utils.get_layer_nr(rec, depth)\n    \n            for htype in self.params[1]:  # htype\n    \n                # pts_per_dec depending on htype\n                if htype == 'Standard':\n                    pts_per_dec = 0\n                elif htype == 'Lagged':\n                    pts_per_dec = -1\n                else:\n                    pts_per_dec = 10\n    \n                # HT arguments\n                _, fhtarg = utils.check_hankel(\n                        'fht', ['key_201_2009', pts_per_dec], 0)\n    \n                # Compute kernels for dlf\n                if VERSION2:\n                    inp = (fhtarg['dlf'], off, fhtarg['pts_per_dec'])\n                    lambd, _ = transform.get_dlf_points(*inp)\n                else:\n                    inp = (fhtarg[0], off, fhtarg[1])\n                    lambd, _ = transform.get_spline_values(*inp)\n    \n                if VERSION2:\n                    inp = (zsrc, zrec, lsrc, lrec, depth, etaH, etaV, zetaH,\n                           zetaV, lambd, ab, xdirect, msrc, mrec)\n                else:\n                    inp = (zsrc, zrec, lsrc, lrec, depth, etaH,\n                           etaV, zetaH, zetaV, lambd, ab, xdirect,\n                           msrc, mrec, use_ne_eval)\n                PJ = kernel.wavenumber(*inp)\n    \n                factAng = kernel.angle_factor(angle, ab, msrc, mrec)\n    \n                # Signature changed at commit a15af07 (20/05/2018; before\n                # v1.6.2)\n                try:\n                    dlf = {'signal': PJ, 'points': lambd, 'out_pts': off,\n                           'ab': ab}\n                    if VERSION2:\n                        dlf['ang_fact'] = factAng\n                        dlf['filt'] = fhtarg['dlf']\n                        dlf['pts_per_dec'] = fhtarg['pts_per_dec']\n                    else:\n                        dlf['factAng'] = factAng\n                        dlf['filt'] = fhtarg[0]\n                        dlf['pts_per_dec'] = fhtarg[1]\n                    transform.dlf(**dlf)\n                except VariableCatch:\n                    dlf = {'signal': PJ, 'points': lambd, 'out_pts': off,\n                           'targ': fhtarg, 'factAng': factAng}\n    \n                data[size][htype] = dlf\n    \n        return data",
        "min_run_count": 2,
        "name": "transform.Dlf.time_dlf",
        "number": 0,
        "param_names": [
            "size",
            "htype"
        ],
        "params": [
            [
                "'Small'",
                "'Big'"
            ],
            [
                "'Standard'",
                "'Lagged'",
                "'Splined'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "setup_cache_key": "/home/dtr/Codes/empymod-asv/benchmarks/transform.py:259",
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "2761d6b174774821bd6f3a68c949345a6a9a9662918de865b305ca097a3ce3f8",
        "warmup_time": -1
    },
    "transform.Fourier.time_dlf_lagged": {
        "code": "class Fourier:\n    def time_dlf_lagged(self, data, size):\n        data[size]['fourier_dlf'](*data[size]['dlf_la'])\n\n    def setup_cache(self):\n        \"\"\"setup_cache is not parametrized, so we do it manually. \"\"\"\n    \n        data = {}\n        for size in self.params[0]:  # size\n            tdat = {}\n    \n            # One big, one small model\n            if size == 'Small':\n                freqtime = np.array([2.])\n            else:\n                freqtime = np.logspace(-1, 1, 11)\n    \n            # Define survey\n            lsrc = 1\n            lrec = 1\n            angle = np.array([0])\n            off = np.array([5000])\n            ab = 11\n            msrc = False\n            mrec = False\n    \n            if VERSION2:\n                zsrc = 250.\n                zrec = 300.\n            else:\n                zsrc = np.array([250.])  # Not sure if this distinction\n                zrec = np.array([300.])  # is actually needed\n                use_ne_eval = False\n    \n            # Define model\n            depth = np.array([-np.infty, 0, 300, 2000, 2100])\n            res = np.array([2e14, .3, 1, 50, 1])\n            aniso = np.ones(res.shape)\n            epermH = np.ones(res.shape)\n            epermV = np.ones(res.shape)\n            mpermH = np.ones(res.shape)\n            mpermV = np.ones(res.shape)\n    \n            # Other parameters\n            verb = 0\n            loop_freq = True\n            loop_off = False\n            signal = 0\n    \n            # Get Hankel arguments\n            if VERSION2:\n                ht, htarg = utils.check_hankel('dlf', ['', -1], verb)\n            else:\n                # `pts_per_dec` changed at 9bed72b0 (29/04/2018; bef. v1.4.1)\n                try:\n                    ht, htarg = utils.check_hankel('fht', ['', -1], verb)\n                except VariableCatch:\n                    # `check_hankel`-signature changed at c73d6647\n                    try:\n                        ht, htarg = utils.check_hankel('fht', None, verb)\n                    except VariableCatch:\n                        ht, htarg = utils.check_hankel('fht', None, ab, verb)\n    \n            # Get frequency-domain stuff for time-domain computation\n            def get_args(freqtime, ft, ftarg):\n                time, freq, ft, ftarg = utils.check_time(\n                        freqtime, signal, ft, ftarg, verb)\n    \n                # Compute eta, zeta\n                etaH = 1/res + np.outer(2j*np.pi*freq, epermH*epsilon_0)\n                etaV = 1/(res*aniso*aniso) + np.outer(2j*np.pi*freq,\n                                                      epermV*epsilon_0)\n                zetaH = np.outer(2j*np.pi*freq, mpermH*mu_0)\n                zetaV = np.outer(2j*np.pi*freq, mpermV*mu_0)\n    \n                # `model.fem`-signature changed on 9bed72b0\n                # (29/04/2018; bef. v1.4.1)\n                inp = (ab, off, angle, zsrc, zrec, lsrc, lrec, depth, freq,\n                       etaH, etaV, zetaH, zetaV, False, False, ht, htarg,\n                       msrc, mrec, loop_freq, loop_off)\n                try:\n                    if not VERSION2:\n                        inp = (*inp[:17], use_ne_eval, *inp[17:])\n                    out = model.fem(*inp)\n                except VariableCatch:\n                    out = model.fem(*inp[:17], True, *inp[17:])\n    \n                # `model.fem` returned in the beginning only fEM;\n                # then (fEM, kcount) and finally (fEM, kcount, conv).\n                if isinstance(out, tuple):\n                    fEM = np.squeeze(out[0])\n                else:\n                    fEM = np.squeeze(out)\n    \n                return (fEM, time, freq, ftarg)\n    \n            # Define function name of transform\n            fft_and_ffht = True\n            if VERSION2:\n                name_dlf = 'fourier_dlf'\n                name_ffht = 'ffht'\n                name_fqwe = 'fourier_qwe'\n                name_fftlog = 'fourier_fftlog'\n                name_fft = 'fourier_fft'\n            else:\n                name_fqwe = 'fqwe'\n                name_fftlog = 'fftlog'\n                name_fft = 'fft'\n                # ffht used to be fft until the introduction of fft\n                try:\n                    getattr(transform, 'ffht')\n                    name_ffht = 'ffht'\n                except VariableCatch:\n                    fft_and_ffht = False\n                    name_ffht = 'fft'\n                name_dlf = name_ffht\n    \n            # Store functions\n            tdat['fourier_dlf'] = getattr(transform, name_dlf)\n            tdat['fourier_qwe'] = getattr(transform, name_fqwe)\n            tdat['fourier_fftlog'] = getattr(transform, name_fftlog)\n            tdat['fourier_fft'] = getattr(transform, name_fft)\n    \n            # Check default pts_per_dec to see if new or old case\n            if VERSION2:\n                old_case = False\n            else:\n                try:\n                    test = utils.check_time(freqtime, signal, 'sin',\n                                            ['key_201_CosSin_2012', 'test'], 0)\n                    old_case = test[3][1] is None\n                except VariableCatch:\n                    old_case = True\n    \n            # Get fourier_dlf arguments\n            if old_case:\n                tdat['dlf_st'] = ()  # Standard was not possible in old case\n                tdat['dlf_la'] = get_args(freqtime, name_ffht, None)\n            else:\n                tdat['dlf_st'] = get_args(\n                        freqtime, name_ffht, ['key_201_CosSin_2012', 0])\n                tdat['dlf_la'] = get_args(\n                        freqtime, name_ffht, ['key_201_CosSin_2012', -1])\n            tdat['dlf_sp'] = get_args(\n                    freqtime, name_ffht, ['key_201_CosSin_2012', 10])\n    \n            # Get fourier_qwe arguments\n            tdat['qwe'] = get_args(freqtime, 'fqwe', ['', '', '', '', 10])\n    \n            # Get fourier_fftlog arguments\n            tdat['fftlog'] = get_args(freqtime, 'fftlog', None)\n    \n            # Get fourier_fft arguments\n            if fft_and_ffht:\n                tdat['fft'] = get_args(freqtime, 'fft', None)\n            else:\n                tdat['fft'] = ()  # Will fail\n    \n            data[size] = tdat\n    \n        return data",
        "min_run_count": 2,
        "name": "transform.Fourier.time_dlf_lagged",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "'Small'",
                "'Big'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "setup_cache_key": "/home/dtr/Codes/empymod-asv/benchmarks/transform.py:381",
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "40a5891ac7ade59f8ce581064fde404f6b671ef606d47a52b804992d41fac657",
        "warmup_time": -1
    },
    "transform.Fourier.time_dlf_splined": {
        "code": "class Fourier:\n    def time_dlf_splined(self, data, size):\n        data[size]['fourier_dlf'](*data[size]['dlf_sp'])\n\n    def setup_cache(self):\n        \"\"\"setup_cache is not parametrized, so we do it manually. \"\"\"\n    \n        data = {}\n        for size in self.params[0]:  # size\n            tdat = {}\n    \n            # One big, one small model\n            if size == 'Small':\n                freqtime = np.array([2.])\n            else:\n                freqtime = np.logspace(-1, 1, 11)\n    \n            # Define survey\n            lsrc = 1\n            lrec = 1\n            angle = np.array([0])\n            off = np.array([5000])\n            ab = 11\n            msrc = False\n            mrec = False\n    \n            if VERSION2:\n                zsrc = 250.\n                zrec = 300.\n            else:\n                zsrc = np.array([250.])  # Not sure if this distinction\n                zrec = np.array([300.])  # is actually needed\n                use_ne_eval = False\n    \n            # Define model\n            depth = np.array([-np.infty, 0, 300, 2000, 2100])\n            res = np.array([2e14, .3, 1, 50, 1])\n            aniso = np.ones(res.shape)\n            epermH = np.ones(res.shape)\n            epermV = np.ones(res.shape)\n            mpermH = np.ones(res.shape)\n            mpermV = np.ones(res.shape)\n    \n            # Other parameters\n            verb = 0\n            loop_freq = True\n            loop_off = False\n            signal = 0\n    \n            # Get Hankel arguments\n            if VERSION2:\n                ht, htarg = utils.check_hankel('dlf', ['', -1], verb)\n            else:\n                # `pts_per_dec` changed at 9bed72b0 (29/04/2018; bef. v1.4.1)\n                try:\n                    ht, htarg = utils.check_hankel('fht', ['', -1], verb)\n                except VariableCatch:\n                    # `check_hankel`-signature changed at c73d6647\n                    try:\n                        ht, htarg = utils.check_hankel('fht', None, verb)\n                    except VariableCatch:\n                        ht, htarg = utils.check_hankel('fht', None, ab, verb)\n    \n            # Get frequency-domain stuff for time-domain computation\n            def get_args(freqtime, ft, ftarg):\n                time, freq, ft, ftarg = utils.check_time(\n                        freqtime, signal, ft, ftarg, verb)\n    \n                # Compute eta, zeta\n                etaH = 1/res + np.outer(2j*np.pi*freq, epermH*epsilon_0)\n                etaV = 1/(res*aniso*aniso) + np.outer(2j*np.pi*freq,\n                                                      epermV*epsilon_0)\n                zetaH = np.outer(2j*np.pi*freq, mpermH*mu_0)\n                zetaV = np.outer(2j*np.pi*freq, mpermV*mu_0)\n    \n                # `model.fem`-signature changed on 9bed72b0\n                # (29/04/2018; bef. v1.4.1)\n                inp = (ab, off, angle, zsrc, zrec, lsrc, lrec, depth, freq,\n                       etaH, etaV, zetaH, zetaV, False, False, ht, htarg,\n                       msrc, mrec, loop_freq, loop_off)\n                try:\n                    if not VERSION2:\n                        inp = (*inp[:17], use_ne_eval, *inp[17:])\n                    out = model.fem(*inp)\n                except VariableCatch:\n                    out = model.fem(*inp[:17], True, *inp[17:])\n    \n                # `model.fem` returned in the beginning only fEM;\n                # then (fEM, kcount) and finally (fEM, kcount, conv).\n                if isinstance(out, tuple):\n                    fEM = np.squeeze(out[0])\n                else:\n                    fEM = np.squeeze(out)\n    \n                return (fEM, time, freq, ftarg)\n    \n            # Define function name of transform\n            fft_and_ffht = True\n            if VERSION2:\n                name_dlf = 'fourier_dlf'\n                name_ffht = 'ffht'\n                name_fqwe = 'fourier_qwe'\n                name_fftlog = 'fourier_fftlog'\n                name_fft = 'fourier_fft'\n            else:\n                name_fqwe = 'fqwe'\n                name_fftlog = 'fftlog'\n                name_fft = 'fft'\n                # ffht used to be fft until the introduction of fft\n                try:\n                    getattr(transform, 'ffht')\n                    name_ffht = 'ffht'\n                except VariableCatch:\n                    fft_and_ffht = False\n                    name_ffht = 'fft'\n                name_dlf = name_ffht\n    \n            # Store functions\n            tdat['fourier_dlf'] = getattr(transform, name_dlf)\n            tdat['fourier_qwe'] = getattr(transform, name_fqwe)\n            tdat['fourier_fftlog'] = getattr(transform, name_fftlog)\n            tdat['fourier_fft'] = getattr(transform, name_fft)\n    \n            # Check default pts_per_dec to see if new or old case\n            if VERSION2:\n                old_case = False\n            else:\n                try:\n                    test = utils.check_time(freqtime, signal, 'sin',\n                                            ['key_201_CosSin_2012', 'test'], 0)\n                    old_case = test[3][1] is None\n                except VariableCatch:\n                    old_case = True\n    \n            # Get fourier_dlf arguments\n            if old_case:\n                tdat['dlf_st'] = ()  # Standard was not possible in old case\n                tdat['dlf_la'] = get_args(freqtime, name_ffht, None)\n            else:\n                tdat['dlf_st'] = get_args(\n                        freqtime, name_ffht, ['key_201_CosSin_2012', 0])\n                tdat['dlf_la'] = get_args(\n                        freqtime, name_ffht, ['key_201_CosSin_2012', -1])\n            tdat['dlf_sp'] = get_args(\n                    freqtime, name_ffht, ['key_201_CosSin_2012', 10])\n    \n            # Get fourier_qwe arguments\n            tdat['qwe'] = get_args(freqtime, 'fqwe', ['', '', '', '', 10])\n    \n            # Get fourier_fftlog arguments\n            tdat['fftlog'] = get_args(freqtime, 'fftlog', None)\n    \n            # Get fourier_fft arguments\n            if fft_and_ffht:\n                tdat['fft'] = get_args(freqtime, 'fft', None)\n            else:\n                tdat['fft'] = ()  # Will fail\n    \n            data[size] = tdat\n    \n        return data",
        "min_run_count": 2,
        "name": "transform.Fourier.time_dlf_splined",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "'Small'",
                "'Big'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "setup_cache_key": "/home/dtr/Codes/empymod-asv/benchmarks/transform.py:381",
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b11da3b790b4b6610aacd47b4d30495784d1caef9c0b25868490d556708c1cfa",
        "warmup_time": -1
    },
    "transform.Fourier.time_dlf_standard": {
        "code": "class Fourier:\n    def time_dlf_standard(self, data, size):\n        data[size]['fourier_dlf'](*data[size]['dlf_st'])\n\n    def setup_cache(self):\n        \"\"\"setup_cache is not parametrized, so we do it manually. \"\"\"\n    \n        data = {}\n        for size in self.params[0]:  # size\n            tdat = {}\n    \n            # One big, one small model\n            if size == 'Small':\n                freqtime = np.array([2.])\n            else:\n                freqtime = np.logspace(-1, 1, 11)\n    \n            # Define survey\n            lsrc = 1\n            lrec = 1\n            angle = np.array([0])\n            off = np.array([5000])\n            ab = 11\n            msrc = False\n            mrec = False\n    \n            if VERSION2:\n                zsrc = 250.\n                zrec = 300.\n            else:\n                zsrc = np.array([250.])  # Not sure if this distinction\n                zrec = np.array([300.])  # is actually needed\n                use_ne_eval = False\n    \n            # Define model\n            depth = np.array([-np.infty, 0, 300, 2000, 2100])\n            res = np.array([2e14, .3, 1, 50, 1])\n            aniso = np.ones(res.shape)\n            epermH = np.ones(res.shape)\n            epermV = np.ones(res.shape)\n            mpermH = np.ones(res.shape)\n            mpermV = np.ones(res.shape)\n    \n            # Other parameters\n            verb = 0\n            loop_freq = True\n            loop_off = False\n            signal = 0\n    \n            # Get Hankel arguments\n            if VERSION2:\n                ht, htarg = utils.check_hankel('dlf', ['', -1], verb)\n            else:\n                # `pts_per_dec` changed at 9bed72b0 (29/04/2018; bef. v1.4.1)\n                try:\n                    ht, htarg = utils.check_hankel('fht', ['', -1], verb)\n                except VariableCatch:\n                    # `check_hankel`-signature changed at c73d6647\n                    try:\n                        ht, htarg = utils.check_hankel('fht', None, verb)\n                    except VariableCatch:\n                        ht, htarg = utils.check_hankel('fht', None, ab, verb)\n    \n            # Get frequency-domain stuff for time-domain computation\n            def get_args(freqtime, ft, ftarg):\n                time, freq, ft, ftarg = utils.check_time(\n                        freqtime, signal, ft, ftarg, verb)\n    \n                # Compute eta, zeta\n                etaH = 1/res + np.outer(2j*np.pi*freq, epermH*epsilon_0)\n                etaV = 1/(res*aniso*aniso) + np.outer(2j*np.pi*freq,\n                                                      epermV*epsilon_0)\n                zetaH = np.outer(2j*np.pi*freq, mpermH*mu_0)\n                zetaV = np.outer(2j*np.pi*freq, mpermV*mu_0)\n    \n                # `model.fem`-signature changed on 9bed72b0\n                # (29/04/2018; bef. v1.4.1)\n                inp = (ab, off, angle, zsrc, zrec, lsrc, lrec, depth, freq,\n                       etaH, etaV, zetaH, zetaV, False, False, ht, htarg,\n                       msrc, mrec, loop_freq, loop_off)\n                try:\n                    if not VERSION2:\n                        inp = (*inp[:17], use_ne_eval, *inp[17:])\n                    out = model.fem(*inp)\n                except VariableCatch:\n                    out = model.fem(*inp[:17], True, *inp[17:])\n    \n                # `model.fem` returned in the beginning only fEM;\n                # then (fEM, kcount) and finally (fEM, kcount, conv).\n                if isinstance(out, tuple):\n                    fEM = np.squeeze(out[0])\n                else:\n                    fEM = np.squeeze(out)\n    \n                return (fEM, time, freq, ftarg)\n    \n            # Define function name of transform\n            fft_and_ffht = True\n            if VERSION2:\n                name_dlf = 'fourier_dlf'\n                name_ffht = 'ffht'\n                name_fqwe = 'fourier_qwe'\n                name_fftlog = 'fourier_fftlog'\n                name_fft = 'fourier_fft'\n            else:\n                name_fqwe = 'fqwe'\n                name_fftlog = 'fftlog'\n                name_fft = 'fft'\n                # ffht used to be fft until the introduction of fft\n                try:\n                    getattr(transform, 'ffht')\n                    name_ffht = 'ffht'\n                except VariableCatch:\n                    fft_and_ffht = False\n                    name_ffht = 'fft'\n                name_dlf = name_ffht\n    \n            # Store functions\n            tdat['fourier_dlf'] = getattr(transform, name_dlf)\n            tdat['fourier_qwe'] = getattr(transform, name_fqwe)\n            tdat['fourier_fftlog'] = getattr(transform, name_fftlog)\n            tdat['fourier_fft'] = getattr(transform, name_fft)\n    \n            # Check default pts_per_dec to see if new or old case\n            if VERSION2:\n                old_case = False\n            else:\n                try:\n                    test = utils.check_time(freqtime, signal, 'sin',\n                                            ['key_201_CosSin_2012', 'test'], 0)\n                    old_case = test[3][1] is None\n                except VariableCatch:\n                    old_case = True\n    \n            # Get fourier_dlf arguments\n            if old_case:\n                tdat['dlf_st'] = ()  # Standard was not possible in old case\n                tdat['dlf_la'] = get_args(freqtime, name_ffht, None)\n            else:\n                tdat['dlf_st'] = get_args(\n                        freqtime, name_ffht, ['key_201_CosSin_2012', 0])\n                tdat['dlf_la'] = get_args(\n                        freqtime, name_ffht, ['key_201_CosSin_2012', -1])\n            tdat['dlf_sp'] = get_args(\n                    freqtime, name_ffht, ['key_201_CosSin_2012', 10])\n    \n            # Get fourier_qwe arguments\n            tdat['qwe'] = get_args(freqtime, 'fqwe', ['', '', '', '', 10])\n    \n            # Get fourier_fftlog arguments\n            tdat['fftlog'] = get_args(freqtime, 'fftlog', None)\n    \n            # Get fourier_fft arguments\n            if fft_and_ffht:\n                tdat['fft'] = get_args(freqtime, 'fft', None)\n            else:\n                tdat['fft'] = ()  # Will fail\n    \n            data[size] = tdat\n    \n        return data",
        "min_run_count": 2,
        "name": "transform.Fourier.time_dlf_standard",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "'Small'",
                "'Big'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "setup_cache_key": "/home/dtr/Codes/empymod-asv/benchmarks/transform.py:381",
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "ba24fa503483182092b2e56c6d571c8700e20d548a8b77025009caf12e3b825d",
        "warmup_time": -1
    },
    "transform.Fourier.time_fft": {
        "code": "class Fourier:\n    def time_fft(self, data, size):\n        data[size]['fourier_fft'](*data[size]['fft'])\n\n    def setup_cache(self):\n        \"\"\"setup_cache is not parametrized, so we do it manually. \"\"\"\n    \n        data = {}\n        for size in self.params[0]:  # size\n            tdat = {}\n    \n            # One big, one small model\n            if size == 'Small':\n                freqtime = np.array([2.])\n            else:\n                freqtime = np.logspace(-1, 1, 11)\n    \n            # Define survey\n            lsrc = 1\n            lrec = 1\n            angle = np.array([0])\n            off = np.array([5000])\n            ab = 11\n            msrc = False\n            mrec = False\n    \n            if VERSION2:\n                zsrc = 250.\n                zrec = 300.\n            else:\n                zsrc = np.array([250.])  # Not sure if this distinction\n                zrec = np.array([300.])  # is actually needed\n                use_ne_eval = False\n    \n            # Define model\n            depth = np.array([-np.infty, 0, 300, 2000, 2100])\n            res = np.array([2e14, .3, 1, 50, 1])\n            aniso = np.ones(res.shape)\n            epermH = np.ones(res.shape)\n            epermV = np.ones(res.shape)\n            mpermH = np.ones(res.shape)\n            mpermV = np.ones(res.shape)\n    \n            # Other parameters\n            verb = 0\n            loop_freq = True\n            loop_off = False\n            signal = 0\n    \n            # Get Hankel arguments\n            if VERSION2:\n                ht, htarg = utils.check_hankel('dlf', ['', -1], verb)\n            else:\n                # `pts_per_dec` changed at 9bed72b0 (29/04/2018; bef. v1.4.1)\n                try:\n                    ht, htarg = utils.check_hankel('fht', ['', -1], verb)\n                except VariableCatch:\n                    # `check_hankel`-signature changed at c73d6647\n                    try:\n                        ht, htarg = utils.check_hankel('fht', None, verb)\n                    except VariableCatch:\n                        ht, htarg = utils.check_hankel('fht', None, ab, verb)\n    \n            # Get frequency-domain stuff for time-domain computation\n            def get_args(freqtime, ft, ftarg):\n                time, freq, ft, ftarg = utils.check_time(\n                        freqtime, signal, ft, ftarg, verb)\n    \n                # Compute eta, zeta\n                etaH = 1/res + np.outer(2j*np.pi*freq, epermH*epsilon_0)\n                etaV = 1/(res*aniso*aniso) + np.outer(2j*np.pi*freq,\n                                                      epermV*epsilon_0)\n                zetaH = np.outer(2j*np.pi*freq, mpermH*mu_0)\n                zetaV = np.outer(2j*np.pi*freq, mpermV*mu_0)\n    \n                # `model.fem`-signature changed on 9bed72b0\n                # (29/04/2018; bef. v1.4.1)\n                inp = (ab, off, angle, zsrc, zrec, lsrc, lrec, depth, freq,\n                       etaH, etaV, zetaH, zetaV, False, False, ht, htarg,\n                       msrc, mrec, loop_freq, loop_off)\n                try:\n                    if not VERSION2:\n                        inp = (*inp[:17], use_ne_eval, *inp[17:])\n                    out = model.fem(*inp)\n                except VariableCatch:\n                    out = model.fem(*inp[:17], True, *inp[17:])\n    \n                # `model.fem` returned in the beginning only fEM;\n                # then (fEM, kcount) and finally (fEM, kcount, conv).\n                if isinstance(out, tuple):\n                    fEM = np.squeeze(out[0])\n                else:\n                    fEM = np.squeeze(out)\n    \n                return (fEM, time, freq, ftarg)\n    \n            # Define function name of transform\n            fft_and_ffht = True\n            if VERSION2:\n                name_dlf = 'fourier_dlf'\n                name_ffht = 'ffht'\n                name_fqwe = 'fourier_qwe'\n                name_fftlog = 'fourier_fftlog'\n                name_fft = 'fourier_fft'\n            else:\n                name_fqwe = 'fqwe'\n                name_fftlog = 'fftlog'\n                name_fft = 'fft'\n                # ffht used to be fft until the introduction of fft\n                try:\n                    getattr(transform, 'ffht')\n                    name_ffht = 'ffht'\n                except VariableCatch:\n                    fft_and_ffht = False\n                    name_ffht = 'fft'\n                name_dlf = name_ffht\n    \n            # Store functions\n            tdat['fourier_dlf'] = getattr(transform, name_dlf)\n            tdat['fourier_qwe'] = getattr(transform, name_fqwe)\n            tdat['fourier_fftlog'] = getattr(transform, name_fftlog)\n            tdat['fourier_fft'] = getattr(transform, name_fft)\n    \n            # Check default pts_per_dec to see if new or old case\n            if VERSION2:\n                old_case = False\n            else:\n                try:\n                    test = utils.check_time(freqtime, signal, 'sin',\n                                            ['key_201_CosSin_2012', 'test'], 0)\n                    old_case = test[3][1] is None\n                except VariableCatch:\n                    old_case = True\n    \n            # Get fourier_dlf arguments\n            if old_case:\n                tdat['dlf_st'] = ()  # Standard was not possible in old case\n                tdat['dlf_la'] = get_args(freqtime, name_ffht, None)\n            else:\n                tdat['dlf_st'] = get_args(\n                        freqtime, name_ffht, ['key_201_CosSin_2012', 0])\n                tdat['dlf_la'] = get_args(\n                        freqtime, name_ffht, ['key_201_CosSin_2012', -1])\n            tdat['dlf_sp'] = get_args(\n                    freqtime, name_ffht, ['key_201_CosSin_2012', 10])\n    \n            # Get fourier_qwe arguments\n            tdat['qwe'] = get_args(freqtime, 'fqwe', ['', '', '', '', 10])\n    \n            # Get fourier_fftlog arguments\n            tdat['fftlog'] = get_args(freqtime, 'fftlog', None)\n    \n            # Get fourier_fft arguments\n            if fft_and_ffht:\n                tdat['fft'] = get_args(freqtime, 'fft', None)\n            else:\n                tdat['fft'] = ()  # Will fail\n    \n            data[size] = tdat\n    \n        return data",
        "min_run_count": 2,
        "name": "transform.Fourier.time_fft",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "'Small'",
                "'Big'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "setup_cache_key": "/home/dtr/Codes/empymod-asv/benchmarks/transform.py:381",
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "819c6e7a607cc55f556052089d240ee593e358ecb3f25579e90bbfb376ee847d",
        "warmup_time": -1
    },
    "transform.Fourier.time_fftlog": {
        "code": "class Fourier:\n    def time_fftlog(self, data, size):\n        data[size]['fourier_fftlog'](*data[size]['fftlog'])\n\n    def setup_cache(self):\n        \"\"\"setup_cache is not parametrized, so we do it manually. \"\"\"\n    \n        data = {}\n        for size in self.params[0]:  # size\n            tdat = {}\n    \n            # One big, one small model\n            if size == 'Small':\n                freqtime = np.array([2.])\n            else:\n                freqtime = np.logspace(-1, 1, 11)\n    \n            # Define survey\n            lsrc = 1\n            lrec = 1\n            angle = np.array([0])\n            off = np.array([5000])\n            ab = 11\n            msrc = False\n            mrec = False\n    \n            if VERSION2:\n                zsrc = 250.\n                zrec = 300.\n            else:\n                zsrc = np.array([250.])  # Not sure if this distinction\n                zrec = np.array([300.])  # is actually needed\n                use_ne_eval = False\n    \n            # Define model\n            depth = np.array([-np.infty, 0, 300, 2000, 2100])\n            res = np.array([2e14, .3, 1, 50, 1])\n            aniso = np.ones(res.shape)\n            epermH = np.ones(res.shape)\n            epermV = np.ones(res.shape)\n            mpermH = np.ones(res.shape)\n            mpermV = np.ones(res.shape)\n    \n            # Other parameters\n            verb = 0\n            loop_freq = True\n            loop_off = False\n            signal = 0\n    \n            # Get Hankel arguments\n            if VERSION2:\n                ht, htarg = utils.check_hankel('dlf', ['', -1], verb)\n            else:\n                # `pts_per_dec` changed at 9bed72b0 (29/04/2018; bef. v1.4.1)\n                try:\n                    ht, htarg = utils.check_hankel('fht', ['', -1], verb)\n                except VariableCatch:\n                    # `check_hankel`-signature changed at c73d6647\n                    try:\n                        ht, htarg = utils.check_hankel('fht', None, verb)\n                    except VariableCatch:\n                        ht, htarg = utils.check_hankel('fht', None, ab, verb)\n    \n            # Get frequency-domain stuff for time-domain computation\n            def get_args(freqtime, ft, ftarg):\n                time, freq, ft, ftarg = utils.check_time(\n                        freqtime, signal, ft, ftarg, verb)\n    \n                # Compute eta, zeta\n                etaH = 1/res + np.outer(2j*np.pi*freq, epermH*epsilon_0)\n                etaV = 1/(res*aniso*aniso) + np.outer(2j*np.pi*freq,\n                                                      epermV*epsilon_0)\n                zetaH = np.outer(2j*np.pi*freq, mpermH*mu_0)\n                zetaV = np.outer(2j*np.pi*freq, mpermV*mu_0)\n    \n                # `model.fem`-signature changed on 9bed72b0\n                # (29/04/2018; bef. v1.4.1)\n                inp = (ab, off, angle, zsrc, zrec, lsrc, lrec, depth, freq,\n                       etaH, etaV, zetaH, zetaV, False, False, ht, htarg,\n                       msrc, mrec, loop_freq, loop_off)\n                try:\n                    if not VERSION2:\n                        inp = (*inp[:17], use_ne_eval, *inp[17:])\n                    out = model.fem(*inp)\n                except VariableCatch:\n                    out = model.fem(*inp[:17], True, *inp[17:])\n    \n                # `model.fem` returned in the beginning only fEM;\n                # then (fEM, kcount) and finally (fEM, kcount, conv).\n                if isinstance(out, tuple):\n                    fEM = np.squeeze(out[0])\n                else:\n                    fEM = np.squeeze(out)\n    \n                return (fEM, time, freq, ftarg)\n    \n            # Define function name of transform\n            fft_and_ffht = True\n            if VERSION2:\n                name_dlf = 'fourier_dlf'\n                name_ffht = 'ffht'\n                name_fqwe = 'fourier_qwe'\n                name_fftlog = 'fourier_fftlog'\n                name_fft = 'fourier_fft'\n            else:\n                name_fqwe = 'fqwe'\n                name_fftlog = 'fftlog'\n                name_fft = 'fft'\n                # ffht used to be fft until the introduction of fft\n                try:\n                    getattr(transform, 'ffht')\n                    name_ffht = 'ffht'\n                except VariableCatch:\n                    fft_and_ffht = False\n                    name_ffht = 'fft'\n                name_dlf = name_ffht\n    \n            # Store functions\n            tdat['fourier_dlf'] = getattr(transform, name_dlf)\n            tdat['fourier_qwe'] = getattr(transform, name_fqwe)\n            tdat['fourier_fftlog'] = getattr(transform, name_fftlog)\n            tdat['fourier_fft'] = getattr(transform, name_fft)\n    \n            # Check default pts_per_dec to see if new or old case\n            if VERSION2:\n                old_case = False\n            else:\n                try:\n                    test = utils.check_time(freqtime, signal, 'sin',\n                                            ['key_201_CosSin_2012', 'test'], 0)\n                    old_case = test[3][1] is None\n                except VariableCatch:\n                    old_case = True\n    \n            # Get fourier_dlf arguments\n            if old_case:\n                tdat['dlf_st'] = ()  # Standard was not possible in old case\n                tdat['dlf_la'] = get_args(freqtime, name_ffht, None)\n            else:\n                tdat['dlf_st'] = get_args(\n                        freqtime, name_ffht, ['key_201_CosSin_2012', 0])\n                tdat['dlf_la'] = get_args(\n                        freqtime, name_ffht, ['key_201_CosSin_2012', -1])\n            tdat['dlf_sp'] = get_args(\n                    freqtime, name_ffht, ['key_201_CosSin_2012', 10])\n    \n            # Get fourier_qwe arguments\n            tdat['qwe'] = get_args(freqtime, 'fqwe', ['', '', '', '', 10])\n    \n            # Get fourier_fftlog arguments\n            tdat['fftlog'] = get_args(freqtime, 'fftlog', None)\n    \n            # Get fourier_fft arguments\n            if fft_and_ffht:\n                tdat['fft'] = get_args(freqtime, 'fft', None)\n            else:\n                tdat['fft'] = ()  # Will fail\n    \n            data[size] = tdat\n    \n        return data",
        "min_run_count": 2,
        "name": "transform.Fourier.time_fftlog",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "'Small'",
                "'Big'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "setup_cache_key": "/home/dtr/Codes/empymod-asv/benchmarks/transform.py:381",
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "24630fc4e4626b943cc1e47497258b5f45841f24ad7aa711d5139c2cb50394d1",
        "warmup_time": -1
    },
    "transform.Fourier.time_qwe": {
        "code": "class Fourier:\n    def time_qwe(self, data, size):\n        data[size]['fourier_qwe'](*data[size]['qwe'])\n\n    def setup_cache(self):\n        \"\"\"setup_cache is not parametrized, so we do it manually. \"\"\"\n    \n        data = {}\n        for size in self.params[0]:  # size\n            tdat = {}\n    \n            # One big, one small model\n            if size == 'Small':\n                freqtime = np.array([2.])\n            else:\n                freqtime = np.logspace(-1, 1, 11)\n    \n            # Define survey\n            lsrc = 1\n            lrec = 1\n            angle = np.array([0])\n            off = np.array([5000])\n            ab = 11\n            msrc = False\n            mrec = False\n    \n            if VERSION2:\n                zsrc = 250.\n                zrec = 300.\n            else:\n                zsrc = np.array([250.])  # Not sure if this distinction\n                zrec = np.array([300.])  # is actually needed\n                use_ne_eval = False\n    \n            # Define model\n            depth = np.array([-np.infty, 0, 300, 2000, 2100])\n            res = np.array([2e14, .3, 1, 50, 1])\n            aniso = np.ones(res.shape)\n            epermH = np.ones(res.shape)\n            epermV = np.ones(res.shape)\n            mpermH = np.ones(res.shape)\n            mpermV = np.ones(res.shape)\n    \n            # Other parameters\n            verb = 0\n            loop_freq = True\n            loop_off = False\n            signal = 0\n    \n            # Get Hankel arguments\n            if VERSION2:\n                ht, htarg = utils.check_hankel('dlf', ['', -1], verb)\n            else:\n                # `pts_per_dec` changed at 9bed72b0 (29/04/2018; bef. v1.4.1)\n                try:\n                    ht, htarg = utils.check_hankel('fht', ['', -1], verb)\n                except VariableCatch:\n                    # `check_hankel`-signature changed at c73d6647\n                    try:\n                        ht, htarg = utils.check_hankel('fht', None, verb)\n                    except VariableCatch:\n                        ht, htarg = utils.check_hankel('fht', None, ab, verb)\n    \n            # Get frequency-domain stuff for time-domain computation\n            def get_args(freqtime, ft, ftarg):\n                time, freq, ft, ftarg = utils.check_time(\n                        freqtime, signal, ft, ftarg, verb)\n    \n                # Compute eta, zeta\n                etaH = 1/res + np.outer(2j*np.pi*freq, epermH*epsilon_0)\n                etaV = 1/(res*aniso*aniso) + np.outer(2j*np.pi*freq,\n                                                      epermV*epsilon_0)\n                zetaH = np.outer(2j*np.pi*freq, mpermH*mu_0)\n                zetaV = np.outer(2j*np.pi*freq, mpermV*mu_0)\n    \n                # `model.fem`-signature changed on 9bed72b0\n                # (29/04/2018; bef. v1.4.1)\n                inp = (ab, off, angle, zsrc, zrec, lsrc, lrec, depth, freq,\n                       etaH, etaV, zetaH, zetaV, False, False, ht, htarg,\n                       msrc, mrec, loop_freq, loop_off)\n                try:\n                    if not VERSION2:\n                        inp = (*inp[:17], use_ne_eval, *inp[17:])\n                    out = model.fem(*inp)\n                except VariableCatch:\n                    out = model.fem(*inp[:17], True, *inp[17:])\n    \n                # `model.fem` returned in the beginning only fEM;\n                # then (fEM, kcount) and finally (fEM, kcount, conv).\n                if isinstance(out, tuple):\n                    fEM = np.squeeze(out[0])\n                else:\n                    fEM = np.squeeze(out)\n    \n                return (fEM, time, freq, ftarg)\n    \n            # Define function name of transform\n            fft_and_ffht = True\n            if VERSION2:\n                name_dlf = 'fourier_dlf'\n                name_ffht = 'ffht'\n                name_fqwe = 'fourier_qwe'\n                name_fftlog = 'fourier_fftlog'\n                name_fft = 'fourier_fft'\n            else:\n                name_fqwe = 'fqwe'\n                name_fftlog = 'fftlog'\n                name_fft = 'fft'\n                # ffht used to be fft until the introduction of fft\n                try:\n                    getattr(transform, 'ffht')\n                    name_ffht = 'ffht'\n                except VariableCatch:\n                    fft_and_ffht = False\n                    name_ffht = 'fft'\n                name_dlf = name_ffht\n    \n            # Store functions\n            tdat['fourier_dlf'] = getattr(transform, name_dlf)\n            tdat['fourier_qwe'] = getattr(transform, name_fqwe)\n            tdat['fourier_fftlog'] = getattr(transform, name_fftlog)\n            tdat['fourier_fft'] = getattr(transform, name_fft)\n    \n            # Check default pts_per_dec to see if new or old case\n            if VERSION2:\n                old_case = False\n            else:\n                try:\n                    test = utils.check_time(freqtime, signal, 'sin',\n                                            ['key_201_CosSin_2012', 'test'], 0)\n                    old_case = test[3][1] is None\n                except VariableCatch:\n                    old_case = True\n    \n            # Get fourier_dlf arguments\n            if old_case:\n                tdat['dlf_st'] = ()  # Standard was not possible in old case\n                tdat['dlf_la'] = get_args(freqtime, name_ffht, None)\n            else:\n                tdat['dlf_st'] = get_args(\n                        freqtime, name_ffht, ['key_201_CosSin_2012', 0])\n                tdat['dlf_la'] = get_args(\n                        freqtime, name_ffht, ['key_201_CosSin_2012', -1])\n            tdat['dlf_sp'] = get_args(\n                    freqtime, name_ffht, ['key_201_CosSin_2012', 10])\n    \n            # Get fourier_qwe arguments\n            tdat['qwe'] = get_args(freqtime, 'fqwe', ['', '', '', '', 10])\n    \n            # Get fourier_fftlog arguments\n            tdat['fftlog'] = get_args(freqtime, 'fftlog', None)\n    \n            # Get fourier_fft arguments\n            if fft_and_ffht:\n                tdat['fft'] = get_args(freqtime, 'fft', None)\n            else:\n                tdat['fft'] = ()  # Will fail\n    \n            data[size] = tdat\n    \n        return data",
        "min_run_count": 2,
        "name": "transform.Fourier.time_qwe",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "'Small'",
                "'Big'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "setup_cache_key": "/home/dtr/Codes/empymod-asv/benchmarks/transform.py:381",
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d5c203fa1e19c8bd8dcf6453eceac63448ab1afb458bb88cc6634003612ec480",
        "warmup_time": -1
    },
    "transform.Hankel.time_fht_lagged": {
        "code": "class Hankel:\n    def time_fht_lagged(self, size):\n        if VERSION2:\n            transform.hankel_dlf(**self.fhtarg_la, **self.hankel)\n        else:\n            transform.fht(**self.fhtarg_la, **self.hankel)\n\n    def setup(self, size):\n    \n        # One big, one small model\n        if size == 'Small':  # Total size: 5*1*1*1 = 5\n            off = np.array([500., 1000.])\n        else:          # Total size: 5*100*1*201 = 100'500\n            off = np.arange(1, 101)*200.\n    \n        # Define survey\n        freq = np.array([1])\n        lsrc = 1\n        lrec = 1\n        angle = np.zeros(off.shape)\n        ab = 11\n        msrc = False\n        mrec = False\n    \n        if VERSION2:\n            zsrc = 250.\n            zrec = 300.\n        else:\n            zsrc = np.array([250.])  # Not sure if this distinction\n            zrec = np.array([300.])  # is actually needed\n            use_ne_eval = False\n    \n        # Define model\n        depth = np.array([-np.infty, 0, 300, 2000, 2100])\n        res = np.array([2e14, .3, 1, 50, 1])\n        aniso = np.ones(res.shape)\n        epermH = np.ones(res.shape)\n        epermV = np.ones(res.shape)\n        mpermH = np.ones(res.shape)\n        mpermV = np.ones(res.shape)\n    \n        # Other parameters\n        xdirect = False\n        verb = 0\n    \n        # Compute eta, zeta\n        etaH = 1/res + np.outer(2j*np.pi*freq, epermH*epsilon_0)\n        etaV = 1/(res*aniso*aniso) + np.outer(2j*np.pi*freq, epermV*epsilon_0)\n        zetaH = np.outer(2j*np.pi*freq, mpermH*mu_0)\n        zetaV = np.outer(2j*np.pi*freq, mpermV*mu_0)\n    \n        # Collect input\n        self.hankel = {'zsrc': zsrc, 'zrec': zrec, 'lsrc': lsrc, 'lrec': lrec,\n                       'off': off, 'depth': depth, 'ab': ab, 'etaH': etaH,\n                       'etaV': etaV, 'zetaH': zetaH, 'zetaV': zetaV, 'xdirect':\n                       xdirect, 'msrc': msrc, 'mrec': mrec}\n        if not VERSION2:\n            self.hankel['use_ne_eval'] = use_ne_eval\n    \n        # Before c73d6647; you had to give `ab` to `check_hankel`;\n        # check_opt didn't exist then.\n        if VERSION2:\n            charg = (verb, )\n            new_version = True\n        else:\n            try:\n                opt = utils.check_opt(None, None, 'fht', ['', 0], verb)\n                charg = (verb, )\n                if np.size(opt) == 4:\n                    new_version = False\n                else:\n                    new_version = True\n            except VariableCatch:\n                new_version = False\n                charg = (ab, verb)\n    \n        # From 9bed72b0 onwards, there is no `use_spline`; `ftarg` input\n        # changed (29/04/2018; before v1.4.1).\n        if new_version:\n            ftarg = ['key_201_2009', -1]\n        else:\n            ftarg = ['key_201_2009', None]\n    \n        # HT arguments\n        if VERSION2:\n            dlfargname = 'htarg'\n            qweargname = 'htarg'\n            quadargname = 'htarg'\n        else:\n            dlfargname = 'fhtarg'\n            qweargname = 'qweargs'\n            quadargname = 'quadargs'\n        _, fhtarg_st = utils.check_hankel('fht', ['key_201_2009', 0], *charg)\n        self.fhtarg_st = {dlfargname: fhtarg_st}\n        _, fhtarg_sp = utils.check_hankel('fht', ['key_201_2009', 10], *charg)\n        self.fhtarg_sp = {dlfargname: fhtarg_sp}\n        _, fhtarg_la = utils.check_hankel('fht', ftarg, *charg)\n        self.fhtarg_la = {dlfargname: fhtarg_la}\n    \n        # QWE: We lower the requirements here, otherwise it takes too long\n        # ['rtol', 'atol', 'nquad', 'maxint', 'pts_per_dec', 'diff_quad', 'a',\n        # 'b', 'limit']\n    \n        # Args depend if QUAD included into QWE or not\n        try:\n            args_sp = [1e-6, 1e-10, 51, 100, 10, np.inf]\n            args_st = [1e-6, 1e-10, 51, 100, 0, np.inf]\n            _, qwearg_sp = utils.check_hankel('qwe', args_sp, *charg)\n            _, qwearg_st = utils.check_hankel('qwe', args_st, *charg)\n        except VariableCatch:\n            args_sp = [1e-6, 1e-10, 51, 100, 10]\n            args_st = [1e-6, 1e-10, 51, 100, 0]\n            _, qwearg_sp = utils.check_hankel('qwe', args_sp, *charg)\n            _, qwearg_st = utils.check_hankel('qwe', args_st, *charg)\n    \n        self.qwearg_st = {qweargname: qwearg_st}\n        self.qwearg_sp = {qweargname: qwearg_sp}\n    \n        # QUAD: We lower the requirements here, otherwise it takes too long\n        # ['rtol', 'atol', 'limit', 'a', 'b', 'pts_per_dec']\n        args = [1e-6, 1e-10, 100, 1e-6, 0.1, 10]\n        try:  # QUAD only included since 6104614e (before v1.3.0)\n            _, quadargs = utils.check_hankel('quad', args, *charg)\n            self.quadargs = {quadargname: quadargs}\n        except VariableCatch:\n            self.quadargs = {}\n    \n        if not new_version and not VERSION2:\n            self.fhtarg_la.update({'use_spline': True})\n            self.fhtarg_sp.update({'use_spline': True})\n            self.fhtarg_st.update({'use_spline': False})\n            self.qwearg_sp.update({'use_spline': True})\n            self.qwearg_st.update({'use_spline': False})\n            self.quadargs.update({'use_spline': True})\n    \n        if VERSION2:\n            self.hankel['ang_fact'] = kernel.angle_factor(\n                    angle, ab, msrc, mrec)\n        else:\n            # From bb6447a onwards ht-transforms take `factAng`, not `angle`,\n            # to avoid re-calculation in loops.\n            try:\n                transform.fht(angle=angle, **self.fhtarg_la, **self.hankel)\n                self.hankel['angle'] = angle\n            except VariableCatch:\n                self.hankel['factAng'] = kernel.angle_factor(\n                        angle, ab, msrc, mrec)\n    \n        if not VERSION2:\n            # From b6f6872 onwards fht-transforms calculates lambd/int_pts in\n            # model.fem, not in transform.fht, to avoid re-calculation in\n            # loops.\n            try:\n                transform.fht(**self.fhtarg_la, **self.hankel)\n            except VariableCatch:\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_st[0], off, fhtarg_st[1])\n                self.fhtarg_st.update({'fhtarg': (\n                    fhtarg_st[0], fhtarg_st[1], lambd, int_pts)})\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_la[0], off, fhtarg_la[1])\n                self.fhtarg_la.update(\n                        {'fhtarg':\n                         (fhtarg_la[0], fhtarg_la[1], lambd, int_pts)})\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_sp[0], off, fhtarg_sp[1])\n                self.fhtarg_sp.update(\n                        {'fhtarg':\n                         (fhtarg_sp[0], fhtarg_sp[1], lambd, int_pts)})",
        "min_run_count": 2,
        "name": "transform.Hankel.time_fht_lagged",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "'Small'",
                "'Big'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "a48e402f4ebd50aa2e35d1b2c2ff670f62367834befcc9b8c70a4d97ee87e852",
        "warmup_time": -1
    },
    "transform.Hankel.time_fht_splined": {
        "code": "class Hankel:\n    def time_fht_splined(self, size):\n        if VERSION2:\n            transform.hankel_dlf(**self.fhtarg_sp, **self.hankel)\n        else:\n            transform.fht(**self.fhtarg_sp, **self.hankel)\n\n    def setup(self, size):\n    \n        # One big, one small model\n        if size == 'Small':  # Total size: 5*1*1*1 = 5\n            off = np.array([500., 1000.])\n        else:          # Total size: 5*100*1*201 = 100'500\n            off = np.arange(1, 101)*200.\n    \n        # Define survey\n        freq = np.array([1])\n        lsrc = 1\n        lrec = 1\n        angle = np.zeros(off.shape)\n        ab = 11\n        msrc = False\n        mrec = False\n    \n        if VERSION2:\n            zsrc = 250.\n            zrec = 300.\n        else:\n            zsrc = np.array([250.])  # Not sure if this distinction\n            zrec = np.array([300.])  # is actually needed\n            use_ne_eval = False\n    \n        # Define model\n        depth = np.array([-np.infty, 0, 300, 2000, 2100])\n        res = np.array([2e14, .3, 1, 50, 1])\n        aniso = np.ones(res.shape)\n        epermH = np.ones(res.shape)\n        epermV = np.ones(res.shape)\n        mpermH = np.ones(res.shape)\n        mpermV = np.ones(res.shape)\n    \n        # Other parameters\n        xdirect = False\n        verb = 0\n    \n        # Compute eta, zeta\n        etaH = 1/res + np.outer(2j*np.pi*freq, epermH*epsilon_0)\n        etaV = 1/(res*aniso*aniso) + np.outer(2j*np.pi*freq, epermV*epsilon_0)\n        zetaH = np.outer(2j*np.pi*freq, mpermH*mu_0)\n        zetaV = np.outer(2j*np.pi*freq, mpermV*mu_0)\n    \n        # Collect input\n        self.hankel = {'zsrc': zsrc, 'zrec': zrec, 'lsrc': lsrc, 'lrec': lrec,\n                       'off': off, 'depth': depth, 'ab': ab, 'etaH': etaH,\n                       'etaV': etaV, 'zetaH': zetaH, 'zetaV': zetaV, 'xdirect':\n                       xdirect, 'msrc': msrc, 'mrec': mrec}\n        if not VERSION2:\n            self.hankel['use_ne_eval'] = use_ne_eval\n    \n        # Before c73d6647; you had to give `ab` to `check_hankel`;\n        # check_opt didn't exist then.\n        if VERSION2:\n            charg = (verb, )\n            new_version = True\n        else:\n            try:\n                opt = utils.check_opt(None, None, 'fht', ['', 0], verb)\n                charg = (verb, )\n                if np.size(opt) == 4:\n                    new_version = False\n                else:\n                    new_version = True\n            except VariableCatch:\n                new_version = False\n                charg = (ab, verb)\n    \n        # From 9bed72b0 onwards, there is no `use_spline`; `ftarg` input\n        # changed (29/04/2018; before v1.4.1).\n        if new_version:\n            ftarg = ['key_201_2009', -1]\n        else:\n            ftarg = ['key_201_2009', None]\n    \n        # HT arguments\n        if VERSION2:\n            dlfargname = 'htarg'\n            qweargname = 'htarg'\n            quadargname = 'htarg'\n        else:\n            dlfargname = 'fhtarg'\n            qweargname = 'qweargs'\n            quadargname = 'quadargs'\n        _, fhtarg_st = utils.check_hankel('fht', ['key_201_2009', 0], *charg)\n        self.fhtarg_st = {dlfargname: fhtarg_st}\n        _, fhtarg_sp = utils.check_hankel('fht', ['key_201_2009', 10], *charg)\n        self.fhtarg_sp = {dlfargname: fhtarg_sp}\n        _, fhtarg_la = utils.check_hankel('fht', ftarg, *charg)\n        self.fhtarg_la = {dlfargname: fhtarg_la}\n    \n        # QWE: We lower the requirements here, otherwise it takes too long\n        # ['rtol', 'atol', 'nquad', 'maxint', 'pts_per_dec', 'diff_quad', 'a',\n        # 'b', 'limit']\n    \n        # Args depend if QUAD included into QWE or not\n        try:\n            args_sp = [1e-6, 1e-10, 51, 100, 10, np.inf]\n            args_st = [1e-6, 1e-10, 51, 100, 0, np.inf]\n            _, qwearg_sp = utils.check_hankel('qwe', args_sp, *charg)\n            _, qwearg_st = utils.check_hankel('qwe', args_st, *charg)\n        except VariableCatch:\n            args_sp = [1e-6, 1e-10, 51, 100, 10]\n            args_st = [1e-6, 1e-10, 51, 100, 0]\n            _, qwearg_sp = utils.check_hankel('qwe', args_sp, *charg)\n            _, qwearg_st = utils.check_hankel('qwe', args_st, *charg)\n    \n        self.qwearg_st = {qweargname: qwearg_st}\n        self.qwearg_sp = {qweargname: qwearg_sp}\n    \n        # QUAD: We lower the requirements here, otherwise it takes too long\n        # ['rtol', 'atol', 'limit', 'a', 'b', 'pts_per_dec']\n        args = [1e-6, 1e-10, 100, 1e-6, 0.1, 10]\n        try:  # QUAD only included since 6104614e (before v1.3.0)\n            _, quadargs = utils.check_hankel('quad', args, *charg)\n            self.quadargs = {quadargname: quadargs}\n        except VariableCatch:\n            self.quadargs = {}\n    \n        if not new_version and not VERSION2:\n            self.fhtarg_la.update({'use_spline': True})\n            self.fhtarg_sp.update({'use_spline': True})\n            self.fhtarg_st.update({'use_spline': False})\n            self.qwearg_sp.update({'use_spline': True})\n            self.qwearg_st.update({'use_spline': False})\n            self.quadargs.update({'use_spline': True})\n    \n        if VERSION2:\n            self.hankel['ang_fact'] = kernel.angle_factor(\n                    angle, ab, msrc, mrec)\n        else:\n            # From bb6447a onwards ht-transforms take `factAng`, not `angle`,\n            # to avoid re-calculation in loops.\n            try:\n                transform.fht(angle=angle, **self.fhtarg_la, **self.hankel)\n                self.hankel['angle'] = angle\n            except VariableCatch:\n                self.hankel['factAng'] = kernel.angle_factor(\n                        angle, ab, msrc, mrec)\n    \n        if not VERSION2:\n            # From b6f6872 onwards fht-transforms calculates lambd/int_pts in\n            # model.fem, not in transform.fht, to avoid re-calculation in\n            # loops.\n            try:\n                transform.fht(**self.fhtarg_la, **self.hankel)\n            except VariableCatch:\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_st[0], off, fhtarg_st[1])\n                self.fhtarg_st.update({'fhtarg': (\n                    fhtarg_st[0], fhtarg_st[1], lambd, int_pts)})\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_la[0], off, fhtarg_la[1])\n                self.fhtarg_la.update(\n                        {'fhtarg':\n                         (fhtarg_la[0], fhtarg_la[1], lambd, int_pts)})\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_sp[0], off, fhtarg_sp[1])\n                self.fhtarg_sp.update(\n                        {'fhtarg':\n                         (fhtarg_sp[0], fhtarg_sp[1], lambd, int_pts)})",
        "min_run_count": 2,
        "name": "transform.Hankel.time_fht_splined",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "'Small'",
                "'Big'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "e1c8cd3114620566a673b64e253c37c346588889618062389b22b6407fb344ab",
        "warmup_time": -1
    },
    "transform.Hankel.time_fht_standard": {
        "code": "class Hankel:\n    def time_fht_standard(self, size):\n        if VERSION2:\n            transform.hankel_dlf(**self.fhtarg_st, **self.hankel)\n        else:\n            transform.fht(**self.fhtarg_st, **self.hankel)\n\n    def setup(self, size):\n    \n        # One big, one small model\n        if size == 'Small':  # Total size: 5*1*1*1 = 5\n            off = np.array([500., 1000.])\n        else:          # Total size: 5*100*1*201 = 100'500\n            off = np.arange(1, 101)*200.\n    \n        # Define survey\n        freq = np.array([1])\n        lsrc = 1\n        lrec = 1\n        angle = np.zeros(off.shape)\n        ab = 11\n        msrc = False\n        mrec = False\n    \n        if VERSION2:\n            zsrc = 250.\n            zrec = 300.\n        else:\n            zsrc = np.array([250.])  # Not sure if this distinction\n            zrec = np.array([300.])  # is actually needed\n            use_ne_eval = False\n    \n        # Define model\n        depth = np.array([-np.infty, 0, 300, 2000, 2100])\n        res = np.array([2e14, .3, 1, 50, 1])\n        aniso = np.ones(res.shape)\n        epermH = np.ones(res.shape)\n        epermV = np.ones(res.shape)\n        mpermH = np.ones(res.shape)\n        mpermV = np.ones(res.shape)\n    \n        # Other parameters\n        xdirect = False\n        verb = 0\n    \n        # Compute eta, zeta\n        etaH = 1/res + np.outer(2j*np.pi*freq, epermH*epsilon_0)\n        etaV = 1/(res*aniso*aniso) + np.outer(2j*np.pi*freq, epermV*epsilon_0)\n        zetaH = np.outer(2j*np.pi*freq, mpermH*mu_0)\n        zetaV = np.outer(2j*np.pi*freq, mpermV*mu_0)\n    \n        # Collect input\n        self.hankel = {'zsrc': zsrc, 'zrec': zrec, 'lsrc': lsrc, 'lrec': lrec,\n                       'off': off, 'depth': depth, 'ab': ab, 'etaH': etaH,\n                       'etaV': etaV, 'zetaH': zetaH, 'zetaV': zetaV, 'xdirect':\n                       xdirect, 'msrc': msrc, 'mrec': mrec}\n        if not VERSION2:\n            self.hankel['use_ne_eval'] = use_ne_eval\n    \n        # Before c73d6647; you had to give `ab` to `check_hankel`;\n        # check_opt didn't exist then.\n        if VERSION2:\n            charg = (verb, )\n            new_version = True\n        else:\n            try:\n                opt = utils.check_opt(None, None, 'fht', ['', 0], verb)\n                charg = (verb, )\n                if np.size(opt) == 4:\n                    new_version = False\n                else:\n                    new_version = True\n            except VariableCatch:\n                new_version = False\n                charg = (ab, verb)\n    \n        # From 9bed72b0 onwards, there is no `use_spline`; `ftarg` input\n        # changed (29/04/2018; before v1.4.1).\n        if new_version:\n            ftarg = ['key_201_2009', -1]\n        else:\n            ftarg = ['key_201_2009', None]\n    \n        # HT arguments\n        if VERSION2:\n            dlfargname = 'htarg'\n            qweargname = 'htarg'\n            quadargname = 'htarg'\n        else:\n            dlfargname = 'fhtarg'\n            qweargname = 'qweargs'\n            quadargname = 'quadargs'\n        _, fhtarg_st = utils.check_hankel('fht', ['key_201_2009', 0], *charg)\n        self.fhtarg_st = {dlfargname: fhtarg_st}\n        _, fhtarg_sp = utils.check_hankel('fht', ['key_201_2009', 10], *charg)\n        self.fhtarg_sp = {dlfargname: fhtarg_sp}\n        _, fhtarg_la = utils.check_hankel('fht', ftarg, *charg)\n        self.fhtarg_la = {dlfargname: fhtarg_la}\n    \n        # QWE: We lower the requirements here, otherwise it takes too long\n        # ['rtol', 'atol', 'nquad', 'maxint', 'pts_per_dec', 'diff_quad', 'a',\n        # 'b', 'limit']\n    \n        # Args depend if QUAD included into QWE or not\n        try:\n            args_sp = [1e-6, 1e-10, 51, 100, 10, np.inf]\n            args_st = [1e-6, 1e-10, 51, 100, 0, np.inf]\n            _, qwearg_sp = utils.check_hankel('qwe', args_sp, *charg)\n            _, qwearg_st = utils.check_hankel('qwe', args_st, *charg)\n        except VariableCatch:\n            args_sp = [1e-6, 1e-10, 51, 100, 10]\n            args_st = [1e-6, 1e-10, 51, 100, 0]\n            _, qwearg_sp = utils.check_hankel('qwe', args_sp, *charg)\n            _, qwearg_st = utils.check_hankel('qwe', args_st, *charg)\n    \n        self.qwearg_st = {qweargname: qwearg_st}\n        self.qwearg_sp = {qweargname: qwearg_sp}\n    \n        # QUAD: We lower the requirements here, otherwise it takes too long\n        # ['rtol', 'atol', 'limit', 'a', 'b', 'pts_per_dec']\n        args = [1e-6, 1e-10, 100, 1e-6, 0.1, 10]\n        try:  # QUAD only included since 6104614e (before v1.3.0)\n            _, quadargs = utils.check_hankel('quad', args, *charg)\n            self.quadargs = {quadargname: quadargs}\n        except VariableCatch:\n            self.quadargs = {}\n    \n        if not new_version and not VERSION2:\n            self.fhtarg_la.update({'use_spline': True})\n            self.fhtarg_sp.update({'use_spline': True})\n            self.fhtarg_st.update({'use_spline': False})\n            self.qwearg_sp.update({'use_spline': True})\n            self.qwearg_st.update({'use_spline': False})\n            self.quadargs.update({'use_spline': True})\n    \n        if VERSION2:\n            self.hankel['ang_fact'] = kernel.angle_factor(\n                    angle, ab, msrc, mrec)\n        else:\n            # From bb6447a onwards ht-transforms take `factAng`, not `angle`,\n            # to avoid re-calculation in loops.\n            try:\n                transform.fht(angle=angle, **self.fhtarg_la, **self.hankel)\n                self.hankel['angle'] = angle\n            except VariableCatch:\n                self.hankel['factAng'] = kernel.angle_factor(\n                        angle, ab, msrc, mrec)\n    \n        if not VERSION2:\n            # From b6f6872 onwards fht-transforms calculates lambd/int_pts in\n            # model.fem, not in transform.fht, to avoid re-calculation in\n            # loops.\n            try:\n                transform.fht(**self.fhtarg_la, **self.hankel)\n            except VariableCatch:\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_st[0], off, fhtarg_st[1])\n                self.fhtarg_st.update({'fhtarg': (\n                    fhtarg_st[0], fhtarg_st[1], lambd, int_pts)})\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_la[0], off, fhtarg_la[1])\n                self.fhtarg_la.update(\n                        {'fhtarg':\n                         (fhtarg_la[0], fhtarg_la[1], lambd, int_pts)})\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_sp[0], off, fhtarg_sp[1])\n                self.fhtarg_sp.update(\n                        {'fhtarg':\n                         (fhtarg_sp[0], fhtarg_sp[1], lambd, int_pts)})",
        "min_run_count": 2,
        "name": "transform.Hankel.time_fht_standard",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "'Small'",
                "'Big'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "761b2a62dde53aebc4e1c1dc6507349dcac9d9c24d9100eeabae2deb1caf351f",
        "warmup_time": -1
    },
    "transform.Hankel.time_hquad": {
        "code": "class Hankel:\n    def time_hquad(self, size):\n        if VERSION2:\n            transform.hankel_quad(**self.quadargs, **self.hankel)\n        else:\n            transform.hquad(**self.quadargs, **self.hankel)\n\n    def setup(self, size):\n    \n        # One big, one small model\n        if size == 'Small':  # Total size: 5*1*1*1 = 5\n            off = np.array([500., 1000.])\n        else:          # Total size: 5*100*1*201 = 100'500\n            off = np.arange(1, 101)*200.\n    \n        # Define survey\n        freq = np.array([1])\n        lsrc = 1\n        lrec = 1\n        angle = np.zeros(off.shape)\n        ab = 11\n        msrc = False\n        mrec = False\n    \n        if VERSION2:\n            zsrc = 250.\n            zrec = 300.\n        else:\n            zsrc = np.array([250.])  # Not sure if this distinction\n            zrec = np.array([300.])  # is actually needed\n            use_ne_eval = False\n    \n        # Define model\n        depth = np.array([-np.infty, 0, 300, 2000, 2100])\n        res = np.array([2e14, .3, 1, 50, 1])\n        aniso = np.ones(res.shape)\n        epermH = np.ones(res.shape)\n        epermV = np.ones(res.shape)\n        mpermH = np.ones(res.shape)\n        mpermV = np.ones(res.shape)\n    \n        # Other parameters\n        xdirect = False\n        verb = 0\n    \n        # Compute eta, zeta\n        etaH = 1/res + np.outer(2j*np.pi*freq, epermH*epsilon_0)\n        etaV = 1/(res*aniso*aniso) + np.outer(2j*np.pi*freq, epermV*epsilon_0)\n        zetaH = np.outer(2j*np.pi*freq, mpermH*mu_0)\n        zetaV = np.outer(2j*np.pi*freq, mpermV*mu_0)\n    \n        # Collect input\n        self.hankel = {'zsrc': zsrc, 'zrec': zrec, 'lsrc': lsrc, 'lrec': lrec,\n                       'off': off, 'depth': depth, 'ab': ab, 'etaH': etaH,\n                       'etaV': etaV, 'zetaH': zetaH, 'zetaV': zetaV, 'xdirect':\n                       xdirect, 'msrc': msrc, 'mrec': mrec}\n        if not VERSION2:\n            self.hankel['use_ne_eval'] = use_ne_eval\n    \n        # Before c73d6647; you had to give `ab` to `check_hankel`;\n        # check_opt didn't exist then.\n        if VERSION2:\n            charg = (verb, )\n            new_version = True\n        else:\n            try:\n                opt = utils.check_opt(None, None, 'fht', ['', 0], verb)\n                charg = (verb, )\n                if np.size(opt) == 4:\n                    new_version = False\n                else:\n                    new_version = True\n            except VariableCatch:\n                new_version = False\n                charg = (ab, verb)\n    \n        # From 9bed72b0 onwards, there is no `use_spline`; `ftarg` input\n        # changed (29/04/2018; before v1.4.1).\n        if new_version:\n            ftarg = ['key_201_2009', -1]\n        else:\n            ftarg = ['key_201_2009', None]\n    \n        # HT arguments\n        if VERSION2:\n            dlfargname = 'htarg'\n            qweargname = 'htarg'\n            quadargname = 'htarg'\n        else:\n            dlfargname = 'fhtarg'\n            qweargname = 'qweargs'\n            quadargname = 'quadargs'\n        _, fhtarg_st = utils.check_hankel('fht', ['key_201_2009', 0], *charg)\n        self.fhtarg_st = {dlfargname: fhtarg_st}\n        _, fhtarg_sp = utils.check_hankel('fht', ['key_201_2009', 10], *charg)\n        self.fhtarg_sp = {dlfargname: fhtarg_sp}\n        _, fhtarg_la = utils.check_hankel('fht', ftarg, *charg)\n        self.fhtarg_la = {dlfargname: fhtarg_la}\n    \n        # QWE: We lower the requirements here, otherwise it takes too long\n        # ['rtol', 'atol', 'nquad', 'maxint', 'pts_per_dec', 'diff_quad', 'a',\n        # 'b', 'limit']\n    \n        # Args depend if QUAD included into QWE or not\n        try:\n            args_sp = [1e-6, 1e-10, 51, 100, 10, np.inf]\n            args_st = [1e-6, 1e-10, 51, 100, 0, np.inf]\n            _, qwearg_sp = utils.check_hankel('qwe', args_sp, *charg)\n            _, qwearg_st = utils.check_hankel('qwe', args_st, *charg)\n        except VariableCatch:\n            args_sp = [1e-6, 1e-10, 51, 100, 10]\n            args_st = [1e-6, 1e-10, 51, 100, 0]\n            _, qwearg_sp = utils.check_hankel('qwe', args_sp, *charg)\n            _, qwearg_st = utils.check_hankel('qwe', args_st, *charg)\n    \n        self.qwearg_st = {qweargname: qwearg_st}\n        self.qwearg_sp = {qweargname: qwearg_sp}\n    \n        # QUAD: We lower the requirements here, otherwise it takes too long\n        # ['rtol', 'atol', 'limit', 'a', 'b', 'pts_per_dec']\n        args = [1e-6, 1e-10, 100, 1e-6, 0.1, 10]\n        try:  # QUAD only included since 6104614e (before v1.3.0)\n            _, quadargs = utils.check_hankel('quad', args, *charg)\n            self.quadargs = {quadargname: quadargs}\n        except VariableCatch:\n            self.quadargs = {}\n    \n        if not new_version and not VERSION2:\n            self.fhtarg_la.update({'use_spline': True})\n            self.fhtarg_sp.update({'use_spline': True})\n            self.fhtarg_st.update({'use_spline': False})\n            self.qwearg_sp.update({'use_spline': True})\n            self.qwearg_st.update({'use_spline': False})\n            self.quadargs.update({'use_spline': True})\n    \n        if VERSION2:\n            self.hankel['ang_fact'] = kernel.angle_factor(\n                    angle, ab, msrc, mrec)\n        else:\n            # From bb6447a onwards ht-transforms take `factAng`, not `angle`,\n            # to avoid re-calculation in loops.\n            try:\n                transform.fht(angle=angle, **self.fhtarg_la, **self.hankel)\n                self.hankel['angle'] = angle\n            except VariableCatch:\n                self.hankel['factAng'] = kernel.angle_factor(\n                        angle, ab, msrc, mrec)\n    \n        if not VERSION2:\n            # From b6f6872 onwards fht-transforms calculates lambd/int_pts in\n            # model.fem, not in transform.fht, to avoid re-calculation in\n            # loops.\n            try:\n                transform.fht(**self.fhtarg_la, **self.hankel)\n            except VariableCatch:\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_st[0], off, fhtarg_st[1])\n                self.fhtarg_st.update({'fhtarg': (\n                    fhtarg_st[0], fhtarg_st[1], lambd, int_pts)})\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_la[0], off, fhtarg_la[1])\n                self.fhtarg_la.update(\n                        {'fhtarg':\n                         (fhtarg_la[0], fhtarg_la[1], lambd, int_pts)})\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_sp[0], off, fhtarg_sp[1])\n                self.fhtarg_sp.update(\n                        {'fhtarg':\n                         (fhtarg_sp[0], fhtarg_sp[1], lambd, int_pts)})",
        "min_run_count": 2,
        "name": "transform.Hankel.time_hquad",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "'Small'",
                "'Big'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "df7857e27cd5642c98e9833badf417b7edf5329da81249afb82512f9144068e0",
        "warmup_time": -1
    },
    "transform.Hankel.time_hqwe_splined": {
        "code": "class Hankel:\n    def time_hqwe_splined(self, size):\n        if VERSION2:\n            transform.hankel_qwe(**self.qwearg_sp, **self.hankel)\n        else:\n            transform.hqwe(**self.qwearg_sp, **self.hankel)\n\n    def setup(self, size):\n    \n        # One big, one small model\n        if size == 'Small':  # Total size: 5*1*1*1 = 5\n            off = np.array([500., 1000.])\n        else:          # Total size: 5*100*1*201 = 100'500\n            off = np.arange(1, 101)*200.\n    \n        # Define survey\n        freq = np.array([1])\n        lsrc = 1\n        lrec = 1\n        angle = np.zeros(off.shape)\n        ab = 11\n        msrc = False\n        mrec = False\n    \n        if VERSION2:\n            zsrc = 250.\n            zrec = 300.\n        else:\n            zsrc = np.array([250.])  # Not sure if this distinction\n            zrec = np.array([300.])  # is actually needed\n            use_ne_eval = False\n    \n        # Define model\n        depth = np.array([-np.infty, 0, 300, 2000, 2100])\n        res = np.array([2e14, .3, 1, 50, 1])\n        aniso = np.ones(res.shape)\n        epermH = np.ones(res.shape)\n        epermV = np.ones(res.shape)\n        mpermH = np.ones(res.shape)\n        mpermV = np.ones(res.shape)\n    \n        # Other parameters\n        xdirect = False\n        verb = 0\n    \n        # Compute eta, zeta\n        etaH = 1/res + np.outer(2j*np.pi*freq, epermH*epsilon_0)\n        etaV = 1/(res*aniso*aniso) + np.outer(2j*np.pi*freq, epermV*epsilon_0)\n        zetaH = np.outer(2j*np.pi*freq, mpermH*mu_0)\n        zetaV = np.outer(2j*np.pi*freq, mpermV*mu_0)\n    \n        # Collect input\n        self.hankel = {'zsrc': zsrc, 'zrec': zrec, 'lsrc': lsrc, 'lrec': lrec,\n                       'off': off, 'depth': depth, 'ab': ab, 'etaH': etaH,\n                       'etaV': etaV, 'zetaH': zetaH, 'zetaV': zetaV, 'xdirect':\n                       xdirect, 'msrc': msrc, 'mrec': mrec}\n        if not VERSION2:\n            self.hankel['use_ne_eval'] = use_ne_eval\n    \n        # Before c73d6647; you had to give `ab` to `check_hankel`;\n        # check_opt didn't exist then.\n        if VERSION2:\n            charg = (verb, )\n            new_version = True\n        else:\n            try:\n                opt = utils.check_opt(None, None, 'fht', ['', 0], verb)\n                charg = (verb, )\n                if np.size(opt) == 4:\n                    new_version = False\n                else:\n                    new_version = True\n            except VariableCatch:\n                new_version = False\n                charg = (ab, verb)\n    \n        # From 9bed72b0 onwards, there is no `use_spline`; `ftarg` input\n        # changed (29/04/2018; before v1.4.1).\n        if new_version:\n            ftarg = ['key_201_2009', -1]\n        else:\n            ftarg = ['key_201_2009', None]\n    \n        # HT arguments\n        if VERSION2:\n            dlfargname = 'htarg'\n            qweargname = 'htarg'\n            quadargname = 'htarg'\n        else:\n            dlfargname = 'fhtarg'\n            qweargname = 'qweargs'\n            quadargname = 'quadargs'\n        _, fhtarg_st = utils.check_hankel('fht', ['key_201_2009', 0], *charg)\n        self.fhtarg_st = {dlfargname: fhtarg_st}\n        _, fhtarg_sp = utils.check_hankel('fht', ['key_201_2009', 10], *charg)\n        self.fhtarg_sp = {dlfargname: fhtarg_sp}\n        _, fhtarg_la = utils.check_hankel('fht', ftarg, *charg)\n        self.fhtarg_la = {dlfargname: fhtarg_la}\n    \n        # QWE: We lower the requirements here, otherwise it takes too long\n        # ['rtol', 'atol', 'nquad', 'maxint', 'pts_per_dec', 'diff_quad', 'a',\n        # 'b', 'limit']\n    \n        # Args depend if QUAD included into QWE or not\n        try:\n            args_sp = [1e-6, 1e-10, 51, 100, 10, np.inf]\n            args_st = [1e-6, 1e-10, 51, 100, 0, np.inf]\n            _, qwearg_sp = utils.check_hankel('qwe', args_sp, *charg)\n            _, qwearg_st = utils.check_hankel('qwe', args_st, *charg)\n        except VariableCatch:\n            args_sp = [1e-6, 1e-10, 51, 100, 10]\n            args_st = [1e-6, 1e-10, 51, 100, 0]\n            _, qwearg_sp = utils.check_hankel('qwe', args_sp, *charg)\n            _, qwearg_st = utils.check_hankel('qwe', args_st, *charg)\n    \n        self.qwearg_st = {qweargname: qwearg_st}\n        self.qwearg_sp = {qweargname: qwearg_sp}\n    \n        # QUAD: We lower the requirements here, otherwise it takes too long\n        # ['rtol', 'atol', 'limit', 'a', 'b', 'pts_per_dec']\n        args = [1e-6, 1e-10, 100, 1e-6, 0.1, 10]\n        try:  # QUAD only included since 6104614e (before v1.3.0)\n            _, quadargs = utils.check_hankel('quad', args, *charg)\n            self.quadargs = {quadargname: quadargs}\n        except VariableCatch:\n            self.quadargs = {}\n    \n        if not new_version and not VERSION2:\n            self.fhtarg_la.update({'use_spline': True})\n            self.fhtarg_sp.update({'use_spline': True})\n            self.fhtarg_st.update({'use_spline': False})\n            self.qwearg_sp.update({'use_spline': True})\n            self.qwearg_st.update({'use_spline': False})\n            self.quadargs.update({'use_spline': True})\n    \n        if VERSION2:\n            self.hankel['ang_fact'] = kernel.angle_factor(\n                    angle, ab, msrc, mrec)\n        else:\n            # From bb6447a onwards ht-transforms take `factAng`, not `angle`,\n            # to avoid re-calculation in loops.\n            try:\n                transform.fht(angle=angle, **self.fhtarg_la, **self.hankel)\n                self.hankel['angle'] = angle\n            except VariableCatch:\n                self.hankel['factAng'] = kernel.angle_factor(\n                        angle, ab, msrc, mrec)\n    \n        if not VERSION2:\n            # From b6f6872 onwards fht-transforms calculates lambd/int_pts in\n            # model.fem, not in transform.fht, to avoid re-calculation in\n            # loops.\n            try:\n                transform.fht(**self.fhtarg_la, **self.hankel)\n            except VariableCatch:\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_st[0], off, fhtarg_st[1])\n                self.fhtarg_st.update({'fhtarg': (\n                    fhtarg_st[0], fhtarg_st[1], lambd, int_pts)})\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_la[0], off, fhtarg_la[1])\n                self.fhtarg_la.update(\n                        {'fhtarg':\n                         (fhtarg_la[0], fhtarg_la[1], lambd, int_pts)})\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_sp[0], off, fhtarg_sp[1])\n                self.fhtarg_sp.update(\n                        {'fhtarg':\n                         (fhtarg_sp[0], fhtarg_sp[1], lambd, int_pts)})",
        "min_run_count": 2,
        "name": "transform.Hankel.time_hqwe_splined",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "'Small'",
                "'Big'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "fb2e3bae034e2ca5b2f7792702b6138264db7b84ded20f55451d6d02b8aa240b",
        "warmup_time": -1
    },
    "transform.Hankel.time_hqwe_standard": {
        "code": "class Hankel:\n    def time_hqwe_standard(self, size):\n        if VERSION2:\n            transform.hankel_qwe(**self.qwearg_st, **self.hankel)\n        else:\n            transform.hqwe(**self.qwearg_st, **self.hankel)\n\n    def setup(self, size):\n    \n        # One big, one small model\n        if size == 'Small':  # Total size: 5*1*1*1 = 5\n            off = np.array([500., 1000.])\n        else:          # Total size: 5*100*1*201 = 100'500\n            off = np.arange(1, 101)*200.\n    \n        # Define survey\n        freq = np.array([1])\n        lsrc = 1\n        lrec = 1\n        angle = np.zeros(off.shape)\n        ab = 11\n        msrc = False\n        mrec = False\n    \n        if VERSION2:\n            zsrc = 250.\n            zrec = 300.\n        else:\n            zsrc = np.array([250.])  # Not sure if this distinction\n            zrec = np.array([300.])  # is actually needed\n            use_ne_eval = False\n    \n        # Define model\n        depth = np.array([-np.infty, 0, 300, 2000, 2100])\n        res = np.array([2e14, .3, 1, 50, 1])\n        aniso = np.ones(res.shape)\n        epermH = np.ones(res.shape)\n        epermV = np.ones(res.shape)\n        mpermH = np.ones(res.shape)\n        mpermV = np.ones(res.shape)\n    \n        # Other parameters\n        xdirect = False\n        verb = 0\n    \n        # Compute eta, zeta\n        etaH = 1/res + np.outer(2j*np.pi*freq, epermH*epsilon_0)\n        etaV = 1/(res*aniso*aniso) + np.outer(2j*np.pi*freq, epermV*epsilon_0)\n        zetaH = np.outer(2j*np.pi*freq, mpermH*mu_0)\n        zetaV = np.outer(2j*np.pi*freq, mpermV*mu_0)\n    \n        # Collect input\n        self.hankel = {'zsrc': zsrc, 'zrec': zrec, 'lsrc': lsrc, 'lrec': lrec,\n                       'off': off, 'depth': depth, 'ab': ab, 'etaH': etaH,\n                       'etaV': etaV, 'zetaH': zetaH, 'zetaV': zetaV, 'xdirect':\n                       xdirect, 'msrc': msrc, 'mrec': mrec}\n        if not VERSION2:\n            self.hankel['use_ne_eval'] = use_ne_eval\n    \n        # Before c73d6647; you had to give `ab` to `check_hankel`;\n        # check_opt didn't exist then.\n        if VERSION2:\n            charg = (verb, )\n            new_version = True\n        else:\n            try:\n                opt = utils.check_opt(None, None, 'fht', ['', 0], verb)\n                charg = (verb, )\n                if np.size(opt) == 4:\n                    new_version = False\n                else:\n                    new_version = True\n            except VariableCatch:\n                new_version = False\n                charg = (ab, verb)\n    \n        # From 9bed72b0 onwards, there is no `use_spline`; `ftarg` input\n        # changed (29/04/2018; before v1.4.1).\n        if new_version:\n            ftarg = ['key_201_2009', -1]\n        else:\n            ftarg = ['key_201_2009', None]\n    \n        # HT arguments\n        if VERSION2:\n            dlfargname = 'htarg'\n            qweargname = 'htarg'\n            quadargname = 'htarg'\n        else:\n            dlfargname = 'fhtarg'\n            qweargname = 'qweargs'\n            quadargname = 'quadargs'\n        _, fhtarg_st = utils.check_hankel('fht', ['key_201_2009', 0], *charg)\n        self.fhtarg_st = {dlfargname: fhtarg_st}\n        _, fhtarg_sp = utils.check_hankel('fht', ['key_201_2009', 10], *charg)\n        self.fhtarg_sp = {dlfargname: fhtarg_sp}\n        _, fhtarg_la = utils.check_hankel('fht', ftarg, *charg)\n        self.fhtarg_la = {dlfargname: fhtarg_la}\n    \n        # QWE: We lower the requirements here, otherwise it takes too long\n        # ['rtol', 'atol', 'nquad', 'maxint', 'pts_per_dec', 'diff_quad', 'a',\n        # 'b', 'limit']\n    \n        # Args depend if QUAD included into QWE or not\n        try:\n            args_sp = [1e-6, 1e-10, 51, 100, 10, np.inf]\n            args_st = [1e-6, 1e-10, 51, 100, 0, np.inf]\n            _, qwearg_sp = utils.check_hankel('qwe', args_sp, *charg)\n            _, qwearg_st = utils.check_hankel('qwe', args_st, *charg)\n        except VariableCatch:\n            args_sp = [1e-6, 1e-10, 51, 100, 10]\n            args_st = [1e-6, 1e-10, 51, 100, 0]\n            _, qwearg_sp = utils.check_hankel('qwe', args_sp, *charg)\n            _, qwearg_st = utils.check_hankel('qwe', args_st, *charg)\n    \n        self.qwearg_st = {qweargname: qwearg_st}\n        self.qwearg_sp = {qweargname: qwearg_sp}\n    \n        # QUAD: We lower the requirements here, otherwise it takes too long\n        # ['rtol', 'atol', 'limit', 'a', 'b', 'pts_per_dec']\n        args = [1e-6, 1e-10, 100, 1e-6, 0.1, 10]\n        try:  # QUAD only included since 6104614e (before v1.3.0)\n            _, quadargs = utils.check_hankel('quad', args, *charg)\n            self.quadargs = {quadargname: quadargs}\n        except VariableCatch:\n            self.quadargs = {}\n    \n        if not new_version and not VERSION2:\n            self.fhtarg_la.update({'use_spline': True})\n            self.fhtarg_sp.update({'use_spline': True})\n            self.fhtarg_st.update({'use_spline': False})\n            self.qwearg_sp.update({'use_spline': True})\n            self.qwearg_st.update({'use_spline': False})\n            self.quadargs.update({'use_spline': True})\n    \n        if VERSION2:\n            self.hankel['ang_fact'] = kernel.angle_factor(\n                    angle, ab, msrc, mrec)\n        else:\n            # From bb6447a onwards ht-transforms take `factAng`, not `angle`,\n            # to avoid re-calculation in loops.\n            try:\n                transform.fht(angle=angle, **self.fhtarg_la, **self.hankel)\n                self.hankel['angle'] = angle\n            except VariableCatch:\n                self.hankel['factAng'] = kernel.angle_factor(\n                        angle, ab, msrc, mrec)\n    \n        if not VERSION2:\n            # From b6f6872 onwards fht-transforms calculates lambd/int_pts in\n            # model.fem, not in transform.fht, to avoid re-calculation in\n            # loops.\n            try:\n                transform.fht(**self.fhtarg_la, **self.hankel)\n            except VariableCatch:\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_st[0], off, fhtarg_st[1])\n                self.fhtarg_st.update({'fhtarg': (\n                    fhtarg_st[0], fhtarg_st[1], lambd, int_pts)})\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_la[0], off, fhtarg_la[1])\n                self.fhtarg_la.update(\n                        {'fhtarg':\n                         (fhtarg_la[0], fhtarg_la[1], lambd, int_pts)})\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_sp[0], off, fhtarg_sp[1])\n                self.fhtarg_sp.update(\n                        {'fhtarg':\n                         (fhtarg_sp[0], fhtarg_sp[1], lambd, int_pts)})",
        "min_run_count": 2,
        "name": "transform.Hankel.time_hqwe_standard",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "'Small'",
                "'Big'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "a77a845dd72084040254b18e5bedce0cfbf231d00467e90855f656027d4f5531",
        "warmup_time": -1
    },
    "version": 2
}